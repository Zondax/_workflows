# DO NOT EDIT THIS FILE
# DO NOT EDIT THIS FILE
# DO NOT EDIT THIS FILE
# DO NOT EDIT THIS FILE
# Generated code
# DO NOT EDIT THIS FILE
# DO NOT EDIT THIS FILE
# DO NOT EDIT THIS FILE
# DO NOT EDIT THIS FILE
GOCMD=go
GOTEST=$(GOCMD) test
COVERFILE       := profile.cov
COVERFILE_TMP   := $(COVERFILE).tmp
EXCLUDE_PATTERN := (_test\.go|_mock\.go|\.pb\.go|mock\.go|/testdata/|/vendor/)

# Get all directories under cmd that contain a file main.go, but only 1 level deep
CMDS=$(shell find cmd -maxdepth 1 -type d -exec test -e '{}/main.go' \; -print)

# Strip cmd/ from directory names and generate output binary names
BINS=$(subst cmd/,output/,$(CMDS))

DEFAULT_APP_NAME ?= api

$(info Using $(shell nproc) CPUs)

## Golang
go-mod-tidy: ## Mod tidy
	@go mod tidy

go-mod-update: ## Mod Update
	@go get -u ./...

go-generate-install:
	@rm -rf internal/version
	@cp -r .make/templates/golang/version internal/

.PHONY: go-generate
go-generate: go-mod-tidy go-generate-install ## Mod generate
	@go generate ./internal/...

output/%: cmd/% FORCE | go-generate
	@echo "$(GREEN)Building $(notdir $<) binary...$(RESET)"
	@mkdir -p $(dir $@)
	@go build -o $@ ./$<

# Special target that forces rules to always run
.PHONY: FORCE
FORCE:

go-list: ## List all available binaries
	@for cmd in $(CMDS); do echo $$cmd; done

go-build: go-generate $(BINS) ## Build
	@# Check for main.go in the root and build if it exists too
	@[ -e main.go ] && go build -v -o output/$(DEFAULT_APP_NAME) || true
	
go-run: go-build ## Run
	@echo "Running $(DEFAULT_APP_NAME)"
	./output/$(DEFAULT_APP_NAME) start

go-version: go-generate ## Get Version
	@echo "Version: $$(cat internal/version/version.txt)"
	@echo "Revision: $$(cat internal/version/revision.txt)"

go-clean: ## Go Clean
	@go clean
	@rm -rf internal/domain/entities/*

go-mod-check: ## Check Modtidy
	@go mod tidy
	@git diff --exit-code -- go.mod go.sum

go-lint: ## Lint
	@golangci-lint --version
	@golangci-lint run

# Dependency helpers
go-lint-install: ## Install go linter `golangci-lint`
	@curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $(shell go env GOPATH)/bin latest

## Test
go-test: go-generate ## Run the tests of the project, excluding integration tests.
ifeq ($(EXPORT_RESULT), true)
	@GO111MODULE=off go get -u github.com/jstemmer/go-junit-report
	@$(eval OUTPUT_OPTIONS = | tee /dev/tty | go-junit-report -set-exit-code > junit-report.xml)
endif
	$(GOTEST) -v -race $(shell go list ./... | grep -v "/internal/tests/integration/") $(OUTPUT_OPTIONS)

go-coverage: go-generate ## Run the tests of the project and export the coverage, options: $EXPORT_RESULT
	## Generate coverage profile
	@$(GOTEST) -covermode=count -coverprofile=$(COVERFILE) ./...
	## Filter out lines of tests, mocks, vendor, etc.
	@if grep -v -E '$(EXCLUDE_PATTERN)' $(COVERFILE) > $(COVERFILE_TMP) 2>/dev/null; then \
		mv $(COVERFILE_TMP) $(COVERFILE); \
	else \
		echo "Warning: No lines to filter or grep failed, keeping original coverage file"; \
	fi
	## Show the coverage summary
	@$(GOCMD) tool cover -func=$(COVERFILE)
ifeq ($(EXPORT_RESULT), true)
	@GO111MODULE=off go get -u github.com/AlekSi/gocov-xml
	@GO111MODULE=off go get -u github.com/axw/gocov/gocov
	@gocov convert $(COVERFILE) | gocov-xml > coverage.xml
endif

.PHONY: *
