# DO NOT EDIT THIS FILE
# DO NOT EDIT THIS FILE
# DO NOT EDIT THIS FILE
# DO NOT EDIT THIS FILE
# Generated code
# DO NOT EDIT THIS FILE
# DO NOT EDIT THIS FILE
# DO NOT EDIT THIS FILE
# DO NOT EDIT THIS FILE
GOCMD=go
GOTEST=$(GOCMD) test
COVERFILE       := profile.cov
COVERFILE_TMP   := $(COVERFILE).tmp
EXCLUDE_PATTERN := (_test\.go|_mock\.go|\.pb\.go|mock\.go|/testdata/|/vendor/)

# Configurable directories
CMD_DIR ?= cmd
INTERNAL_DIR ?= internal
OUTPUT_DIR ?= output

# Get all directories under CMD_DIR that contain a file main.go
# Support both flat structure (cmd/service/main.go) and nested (services/service/cmd/main.go)
CMDS=$(shell find $(CMD_DIR) -maxdepth 3 -name "main.go" -path "*/cmd/main.go" -exec dirname {} \; 2>/dev/null || find $(CMD_DIR) -maxdepth 1 -type d -exec test -e '{}/main.go' \; -print 2>/dev/null)

# Strip CMD_DIR/ from directory names and generate output binary names
# For nested structure like services/api/cmd -> output/api
BINS=$(patsubst $(CMD_DIR)/%,$(OUTPUT_DIR)/%,$(CMDS))
BINS:=$(subst /cmd,,$(BINS))

DEFAULT_APP_NAME ?= api

$(info Using $(shell nproc 2>/dev/null || echo 1) CPUs)

## Golang
go-mod-tidy: ## Mod tidy
	@go mod tidy

go-mod-update: ## Mod Update
	@go get -u ./...

go-generate-install:
	@rm -rf $(INTERNAL_DIR)/version
	@cp -r .make/templates/golang/version $(INTERNAL_DIR)/

.PHONY: go-generate
go-generate: go-mod-tidy go-generate-install ## Mod generate
	@go generate ./$(INTERNAL_DIR)/...

$(OUTPUT_DIR)/%: $(CMD_DIR)/% FORCE | go-generate
	@echo "$(GREEN)Building $(notdir $<) binary...$(RESET)"
	@mkdir -p $(dir $@)
	@if [ -d "$</cmd" ]; then \
		go build -o $@ ./$</cmd; \
	else \
		go build -o $@ ./$<; \
	fi

# Special target that forces rules to always run
.PHONY: FORCE
FORCE:

go-list: ## List all available binaries
	@for cmd in $(CMDS); do echo $$cmd; done

go-build: go-generate $(BINS) ## Build
	@# Check for main.go in the root and build if it exists too
	@[ -e main.go ] && go build -v -o $(OUTPUT_DIR)/$(DEFAULT_APP_NAME) || true
	
go-run: go-build ## Run
	@echo "Running $(DEFAULT_APP_NAME)"
	./$(OUTPUT_DIR)/$(DEFAULT_APP_NAME) start

go-version: go-generate ## Get Version
	@echo "Version: $$(cat $(INTERNAL_DIR)/version/version.txt)"
	@echo "Revision: $$(cat $(INTERNAL_DIR)/version/revision.txt)"

go-clean: ## Go Clean
	@go clean
	@rm -rf $(INTERNAL_DIR)/domain/entities/*

go-mod-check: ## Check Modtidy
	@go mod tidy
	@git diff --exit-code -- go.mod go.sum

go-lint: ## Lint
	@golangci-lint --version
	@golangci-lint run

# Dependency helpers
go-lint-install: ## Install go linter `golangci-lint`
	@curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $(shell go env GOPATH)/bin latest

## Test
go-test: go-generate ## Run the tests of the project, excluding integration tests.
ifeq ($(EXPORT_RESULT), true)
	@GO111MODULE=off go get -u github.com/jstemmer/go-junit-report
	@$(eval OUTPUT_OPTIONS = | tee /dev/tty | go-junit-report -set-exit-code > junit-report.xml)
endif
	$(GOTEST) -v -race $(shell go list ./... | grep -v "/$(INTERNAL_DIR)/tests/integration/") $(OUTPUT_OPTIONS)

go-coverage: go-generate ## Run the tests of the project and export the coverage, options: $EXPORT_RESULT
	## Generate coverage profile
	@$(GOTEST) -covermode=count -coverprofile=$(COVERFILE) ./...
	## Filter out lines of tests, mocks, vendor, etc.
	@if grep -v -E '$(EXCLUDE_PATTERN)' $(COVERFILE) > $(COVERFILE_TMP) 2>/dev/null; then \
		mv $(COVERFILE_TMP) $(COVERFILE); \
	else \
		echo "Warning: No lines to filter or grep failed, keeping original coverage file"; \
	fi
	## Show the coverage summary
	@$(GOCMD) tool cover -func=$(COVERFILE)
ifeq ($(EXPORT_RESULT), true)
	@GO111MODULE=off go get -u github.com/AlekSi/gocov-xml
	@GO111MODULE=off go get -u github.com/axw/gocov/gocov
	@gocov convert $(COVERFILE) | gocov-xml > coverage.xml
endif

.PHONY: *
