name: Cloud Run Deploy (Reusable)

on:
  workflow_call:
    inputs:
      service_name:
        required: false
        type: string
        description: Name of the Cloud Run service
      gcp_project_id:
        required: true
        type: string
        description: GCP project ID
      image_tag:
        required: true
        type: string
        description: Full image tag to deploy
      region:
        required: true
        type: string
        description: GCP region for Cloud Run
      allow_unauth:
        required: false
        type: boolean
        default: true
        description: Whether to allow unauthenticated access
      config_file:
        required: false
        type: string
        description: Path to the configuration file for this deployment
      workload_identity_provider:
        required: true
        type: string
        description: Workload identity provider
      service_account:
        required: true
        type: string
      container_images:
        required: false
        type: string
        description: JSON map of container name to image (for multi-container deploys)
    outputs:
      url:
        description: "The deployed Cloud Run service URL."
        value: ${{ jobs.deploy.outputs.url }}
jobs:
  deploy:
    runs-on: zondax-runners
    outputs:
      url: ${{ steps.get-url.outputs.url }}
    permissions:
      id-token: write # Enables automatic ID token injection for google-github-actions/auth
      contents: read # Required for actions/checkout and GitHub API access
      pull-requests: write # Required for commenting on PRs
    steps:
      - uses: actions/checkout@v4
      - id: auth
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ inputs.workload_identity_provider }}
          service_account: ${{ inputs.service_account }}
          
      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        
      - name: Install go
        uses: actions/setup-go@v5
        with:
          go-version: 1.24

      - name: Install yq
        run: |
          go install github.com/mikefarah/yq/v4@latest
          
      - name: Read config file
        id: read-config
        if: inputs.config_file != ''
        run: |
          echo "Reading configuration from ${{ inputs.config_file }}"
          if [ -f "${{ inputs.config_file }}" ]; then
            SERVICE_NAME=$(yq e -r '(.service.name // "")' ${{ inputs.config_file }})
            MEMORY=$(yq e -r '(.service.memory // "")' ${{ inputs.config_file }})
            CPU=$(yq e -r '(.service.cpu // "")' ${{ inputs.config_file }})
            CONCURRENCY=$(yq e -r '(.service.concurrency // "")' ${{ inputs.config_file }})
            TIMEOUT=$(yq e -r '(.service.timeout // "")' ${{ inputs.config_file }})
            MIN_INSTANCES=$(yq e -r '(.service.min_instances // "")' ${{ inputs.config_file }})
            MAX_INSTANCES=$(yq e -r '(.service.max_instances // "")' ${{ inputs.config_file }})
            ALLOW_UNAUTH=$(yq e -r '(.service.allow_unauthenticated // "true")' ${{ inputs.config_file }})
            VPC_CONNECTOR=$(yq e -r '(.service.vpc_connector // "")' ${{ inputs.config_file }})
            PORT=$(yq e -r '(.service.port // "")' ${{ inputs.config_file }})
            
            # Debug service level values
            echo "[DEBUG] Service level variables:"
            echo "[DEBUG] SERVICE_NAME='$SERVICE_NAME'"
            echo "[DEBUG] MEMORY='$MEMORY'"
            echo "[DEBUG] CPU='$CPU'"
            echo "[DEBUG] CONCURRENCY='$CONCURRENCY'"
            echo "[DEBUG] TIMEOUT='$TIMEOUT'"
            echo "[DEBUG] MIN_INSTANCES='$MIN_INSTANCES'"
            echo "[DEBUG] MAX_INSTANCES='$MAX_INSTANCES'"
            echo "[DEBUG] ALLOW_UNAUTH='$ALLOW_UNAUTH'"
            echo "[DEBUG] VPC_CONNECTOR='$VPC_CONNECTOR'"
            echo "[DEBUG] PORT='$PORT'"
            
            # Check if this is a multi-container configuration
            if yq e '.service.containers | length > 0' ${{ inputs.config_file }} &>/dev/null; then
              HAS_CONTAINERS="true"
            else
              HAS_CONTAINERS="false"
            fi
            echo "has_containers=$HAS_CONTAINERS" >> $GITHUB_OUTPUT
            
            # If single container configuration
            if [ "$HAS_CONTAINERS" = "false" ]; then
              # Build environment variables flags
              ENV_VARS="--set-env-vars="
              for key in $(yq '.service.environment_variables | keys | .[]' ${{ inputs.config_file }}); do
                value=$(yq ".service.environment_variables.$key" ${{ inputs.config_file }})
                ENV_VARS="$ENV_VARS$key=$value,"
              done
  
              ENV_VARS=${ENV_VARS%,}
  
              # Parse command and args as comma-separated and space-separated strings
              COMMAND=$(yq -o=json '.service.command // []' ${{ inputs.config_file }} | jq -r 'join(",")')
              ARGS=$(yq -o=json '.service.args // []' ${{ inputs.config_file }} | jq -r 'join(" ")')
  
              # Debug: print values before writing to output
              echo "[DEBUG] env_vars: '$ENV_VARS'"
              echo "[DEBUG] command: '$COMMAND'"
              echo "[DEBUG] args: '$ARGS'"
  
              # Only write non-empty, trimmed values to $GITHUB_OUTPUT
              for var in env_vars command args; do
                value=$(eval echo \$$var | sed 's/^ *//;s/ *$//')
                if [ -n "$value" ]; then
                  echo "$var=$value" >> $GITHUB_OUTPUT
                fi
              done
              echo "is_multi_container=false" >> $GITHUB_OUTPUT
            else
              # Multi-container configuration
              echo "Detected multi-container configuration"
              
              # Build container configuration for gcloud
              CONTAINERS_CONFIG="--container-command="
              CONTAINERS_ARGS="--container-arg="
              CONTAINERS_ENV="--container-env-vars="
              CONTAINERS_IMAGE="--container-image="
              CONTAINERS_MEMORY="--container-memory="
              CONTAINERS_CPU="--container-cpu="
              CONTAINERS_PORT="--container-port="

              # Process each container
              CONTAINERS_COUNT=$(yq '.service.containers | length' ${{ inputs.config_file }})
              # Parse container_images input as JSON
              if [ -n "${{ inputs.container_images }}" ]; then
                CONTAINER_IMAGES_JSON='${{ inputs.container_images }}'
              else
                echo "Error: container_images input is required for multi-container deployments" >&2
                exit 1
              fi
              for i in $(seq 0 $(($CONTAINERS_COUNT-1))); do
                CONTAINER_NAME=$(yq e -r ".service.containers[$i].name // \"\"" ${{ inputs.config_file }})
                echo "[DEBUG] Processing container: $CONTAINER_NAME"

                # Process container command
                CONTAINER_COMMAND=$(yq -o=json ".service.containers[$i].command // []" ${{ inputs.config_file }} | jq -r 'join(",")')
                echo "[DEBUG] CONTAINER_COMMAND='$CONTAINER_COMMAND'"
                if [ "$CONTAINER_COMMAND" != "" ]; then
                  CONTAINERS_CONFIG="${CONTAINERS_CONFIG}${CONTAINER_NAME}=${CONTAINER_COMMAND},"
                fi
                
                # Process container args
                CONTAINER_ARGS=$(yq -o=json ".service.containers[$i].args // []" ${{ inputs.config_file }} | jq -r 'join(" ")')
                echo "[DEBUG] CONTAINER_ARGS='$CONTAINER_ARGS'"
                if [ "$CONTAINER_ARGS" != "" ]; then
                  # Properly escape container args 
                  ESCAPED_ARGS=$(echo "$CONTAINER_ARGS" | sed 's/"/\\"/g')
                  CONTAINERS_ARGS="${CONTAINERS_ARGS}${CONTAINER_NAME}=\"${ESCAPED_ARGS}\"," 
                fi
                
                # Process container environment variables
                CONTAINER_ENV=""
                for key in $(yq e -r ".service.containers[$i].environment_variables | keys | .[]" ${{ inputs.config_file }}); do
                  value=$(yq e -r ".service.containers[$i].environment_variables.${key} // \"\"" ${{ inputs.config_file }})
                  # Special handling for variables that need to be replaced
                  if [ "$value" = "\${API_CONFIG_B64}" ] && [ "$APP_CONFIG_FILE_B64" != "" ]; then
                    value="$APP_CONFIG_FILE_B64"
                  elif [ "$value" = "\${SIDECAR_CONFIG_B64}" ] && [ "$SIDECAR_CONFIG_FILE_B64" != "" ]; then
                    value="$SIDECAR_CONFIG_FILE_B64"
                  fi
                  if [ "$CONTAINER_ENV" != "" ]; then
                    CONTAINER_ENV="${CONTAINER_ENV},$key=$value"
                  else
                    CONTAINER_ENV="$key=$value"
                  fi
                done
                if [ "$CONTAINER_ENV" != "" ]; then
                  CONTAINERS_ENV="${CONTAINERS_ENV}${CONTAINER_NAME}=${CONTAINER_ENV},"
                fi
                # Image always comes from the input 'container_images', never from the config file
                CONTAINER_IMAGE=$(echo "$CONTAINER_IMAGES_JSON" | jq -r ".[\"$CONTAINER_NAME\"]")
                if [ "$CONTAINER_IMAGE" = "null" ] || [ -z "$CONTAINER_IMAGE" ]; then
                  echo "Error: No image provided for container $CONTAINER_NAME in container_images input" >&2
                  exit 1
                fi
                CONTAINERS_IMAGE="${CONTAINERS_IMAGE}${CONTAINER_NAME}=${CONTAINER_IMAGE},"
                # Process container memory
                CONTAINER_MEMORY=$(yq e -r ".service.containers[$i].memory // \"\"" ${{ inputs.config_file }} | tr -d ' ' | sed 's/^ *//;s/ *$//;s/\r//g' | tr -d '\n')
                # Check for problem format of memory: 212Mi (YAML snippet) - common issue
                if echo "$CONTAINER_MEMORY" | grep -q "memory:" || echo "$CONTAINER_MEMORY" | grep -q ":"; then
                  echo "[WARN] Found problematic YAML format in memory value: $CONTAINER_MEMORY" >&2
                  CONTAINER_MEMORY=$(echo "$CONTAINER_MEMORY" | sed 's/.*://g' | tr -d ' ')
                  echo "[WARN] Cleaned to: $CONTAINER_MEMORY" >&2
                fi
                CONTAINERS_MEMORY="${CONTAINERS_MEMORY}${CONTAINER_NAME}=${CONTAINER_MEMORY},"
                # Process container cpu
                CONTAINER_CPU=$(yq e -r ".service.containers[$i].cpu // \"\"" ${{ inputs.config_file }} | tr -d ' ')
                CONTAINERS_CPU="${CONTAINERS_CPU}${CONTAINER_NAME}=${CONTAINER_CPU},"
                # Process container port
                CONTAINER_PORT=$(yq e -r ".service.containers[$i].port // \"\"" ${{ inputs.config_file }} | tr -d ' ')
                CONTAINERS_PORT="${CONTAINERS_PORT}${CONTAINER_NAME}=${CONTAINER_PORT},"
              done
              
              # Trim trailing commas
              CONTAINERS_CONFIG=${CONTAINERS_CONFIG%,}
              CONTAINERS_ARGS=${CONTAINERS_ARGS%,}
              CONTAINERS_ENV=${CONTAINERS_ENV%,}
              CONTAINERS_IMAGE=${CONTAINERS_IMAGE%,}
              CONTAINERS_MEMORY=${CONTAINERS_MEMORY%,}
              CONTAINERS_CPU=${CONTAINERS_CPU%,}
              CONTAINERS_PORT=${CONTAINERS_PORT%,}

              # Debug: print values before writing to output
              echo "[DEBUG] containers_config: '$CONTAINERS_CONFIG'"
              echo "[DEBUG] containers_args: '$CONTAINERS_ARGS'"
              echo "[DEBUG] containers_env: '$CONTAINERS_ENV'"
              echo "[DEBUG] containers_image: '$CONTAINERS_IMAGE'"
              echo "[DEBUG] containers_memory: '$CONTAINERS_MEMORY'"
              echo "[DEBUG] containers_cpu: '$CONTAINERS_CPU'"
              echo "[DEBUG] containers_port: '$CONTAINERS_PORT'"

              # Only write non-empty, trimmed, single-line values to $GITHUB_OUTPUT
              for var in containers_config containers_args containers_env containers_image containers_memory containers_cpu containers_port; do
                value=$(eval echo \$$var | sed 's/^ *//;s/ *$//;s/\r//g' | tr -d '\n')
                echo "[DEBUG] About to write to GITHUB_OUTPUT: $var='$value'"
                if [ -n "$value" ]; then
                  # Ensure value does not contain '=' or newlines
                  if echo "$value" | grep -q '='; then
                    echo "[ERROR] Value for $var contains '=': $value" >&2
                    continue
                  fi
                  echo "$var=$value" >> $GITHUB_OUTPUT
                fi
              done
              echo "is_multi_container=true" >> $GITHUB_OUTPUT

            # Process app_config_file and sidecar_config_file for both single and multi-container
              APP_CONFIG_FILE=$(yq e -r '(.service.app_config_file // "")' ${{ inputs.config_file }})
              if [ "$APP_CONFIG_FILE" != "" ]; then
              # Replace github_event_number with the actual value in the app config file
                APP_CONFIG_FILE_REPLACED=$(echo "$APP_CONFIG_FILE" | sed "s/github_event_number/${{ github.event.number }}/g")
                APP_CONFIG_FILE_B64=$(echo "$APP_CONFIG_FILE_REPLACED" | base64 | tr -d '\n')
                echo "app_config_file_b64=$APP_CONFIG_FILE_B64" >> $GITHUB_OUTPUT
              fi

              SIDECAR_CONFIG_FILE=$(yq e -r '(.service.sidecar_config_file // "")' ${{ inputs.config_file }})
              if [ "$SIDECAR_CONFIG_FILE" != "" ]; then
              # Replace github_event_number with the actual value in the sidecar config file
                SIDECAR_CONFIG_FILE_REPLACED=$(echo "$SIDECAR_CONFIG_FILE" | sed "s/github_event_number/${{ github.event.number }}/g")
                SIDECAR_CONFIG_FILE_B64=$(echo "$SIDECAR_CONFIG_FILE_REPLACED" | base64 | tr -d '\n')
                echo "sidecar_config_file_b64=$SIDECAR_CONFIG_FILE_B64" >> $GITHUB_OUTPUT
              fi
            fi

            # Parse health check config for startup and liveness probes
            STARTUP_PROBE_FLAG=""
            LIVENESS_PROBE_FLAG=""
            # Startup probe
            STARTUP=$(yq e -r '(.service.health_check.startup // "")' ${{ inputs.config_file }})
            if [ "$STARTUP" != "" ]; then
              PROBE_TYPE=$(yq e -r '(.service.health_check.startup.type // "")' ${{ inputs.config_file }})
              if [ "$PROBE_TYPE" = "grpc" ]; then
                PROBE_PORT=$(yq e -r '(.service.health_check.startup.port // "")' ${{ inputs.config_file }})
                PROBE_SERVICE=$(yq e -r '(.service.health_check.startup.service // "")' ${{ inputs.config_file }})
                PROBE_DELAY=$(yq e -r '(.service.health_check.startup.initial_delay_seconds // "0")' ${{ inputs.config_file }})
                PROBE_PERIOD=$(yq e -r '(.service.health_check.startup.period_seconds // "10")' ${{ inputs.config_file }})
                PROBE_TIMEOUT=$(yq e -r '(.service.health_check.startup.timeout_seconds // "1")' ${{ inputs.config_file }})
                PROBE_FAILURE=$(yq e -r '(.service.health_check.startup.failure_threshold // "3")' ${{ inputs.config_file }})
                STARTUP_PROBE_FLAG="--startup-probe grpc.port=$PROBE_PORT,grpc.service=$PROBE_SERVICE,initialDelaySeconds=$PROBE_DELAY,periodSeconds=$PROBE_PERIOD,timeoutSeconds=$PROBE_TIMEOUT,failureThreshold=$PROBE_FAILURE"
              elif [ "$PROBE_TYPE" = "http" ]; then
                PROBE_PATH=$(yq e -r '(.service.health_check.startup.path // "")' ${{ inputs.config_file }})
                PROBE_PORT=$(yq e -r '(.service.health_check.startup.port // "")' ${{ inputs.config_file }})
                PROBE_DELAY=$(yq e -r '(.service.health_check.startup.initial_delay_seconds // "0")' ${{ inputs.config_file }})
                PROBE_PERIOD=$(yq e -r '(.service.health_check.startup.period_seconds // "10")' ${{ inputs.config_file }})
                PROBE_TIMEOUT=$(yq e -r '(.service.health_check.startup.timeout_seconds // "1")' ${{ inputs.config_file }})
                PROBE_FAILURE=$(yq e -r '(.service.health_check.startup.failure_threshold // "3")' ${{ inputs.config_file }})
                STARTUP_PROBE_FLAG="--startup-probe httpGet.path=$PROBE_PATH,httpGet.port=$PROBE_PORT,initialDelaySeconds=$PROBE_DELAY,periodSeconds=$PROBE_PERIOD,timeoutSeconds=$PROBE_TIMEOUT,failureThreshold=$PROBE_FAILURE"
              fi
              if [ -n "$STARTUP_PROBE_FLAG" ]; then echo "startup_probe_flag=$STARTUP_PROBE_FLAG" >> $GITHUB_OUTPUT; fi
            fi
            # Liveness probe
            LIVENESS=$(yq e -r '(.service.health_check.liveness // "")' ${{ inputs.config_file }})
            if [ "$LIVENESS" != "" ]; then
              PROBE_TYPE=$(yq e -r '(.service.health_check.liveness.type // "")' ${{ inputs.config_file }})
              if [ "$PROBE_TYPE" = "grpc" ]; then
                PROBE_PORT=$(yq e -r '(.service.health_check.liveness.port // "")' ${{ inputs.config_file }})
                PROBE_SERVICE=$(yq e -r '(.service.health_check.liveness.service // "")' ${{ inputs.config_file }})
                PROBE_DELAY=$(yq e -r '(.service.health_check.liveness.initial_delay_seconds // "0")' ${{ inputs.config_file }})
                PROBE_PERIOD=$(yq e -r '(.service.health_check.liveness.period_seconds // "10")' ${{ inputs.config_file }})
                PROBE_TIMEOUT=$(yq e -r '(.service.health_check.liveness.timeout_seconds // "1")' ${{ inputs.config_file }})
                PROBE_FAILURE=$(yq e -r '(.service.health_check.liveness.failure_threshold // "3")' ${{ inputs.config_file }})
                LIVENESS_PROBE_FLAG="--liveness-probe grpc.port=$PROBE_PORT,grpc.service=$PROBE_SERVICE,initialDelaySeconds=$PROBE_DELAY,periodSeconds=$PROBE_PERIOD,timeoutSeconds=$PROBE_TIMEOUT,failureThreshold=$PROBE_FAILURE"
              elif [ "$PROBE_TYPE" = "http" ]; then
                PROBE_PATH=$(yq e -r '(.service.health_check.liveness.path // "")' ${{ inputs.config_file }})
                PROBE_PORT=$(yq e -r '(.service.health_check.liveness.port // "")' ${{ inputs.config_file }})
                PROBE_DELAY=$(yq e -r '(.service.health_check.liveness.initial_delay_seconds // "0")' ${{ inputs.config_file }})
                PROBE_PERIOD=$(yq e -r '(.service.health_check.liveness.period_seconds // "10")' ${{ inputs.config_file }})
                PROBE_TIMEOUT=$(yq e -r '(.service.health_check.liveness.timeout_seconds // "1")' ${{ inputs.config_file }})
                PROBE_FAILURE=$(yq e -r '(.service.health_check.liveness.failure_threshold // "3")' ${{ inputs.config_file }})
                LIVENESS_PROBE_FLAG="--liveness-probe httpGet.path=$PROBE_PATH,httpGet.port=$PROBE_PORT,initialDelaySeconds=$PROBE_DELAY,periodSeconds=$PROBE_PERIOD,timeoutSeconds=$PROBE_TIMEOUT,failureThreshold=$PROBE_FAILURE"
              fi
              if [ -n "$LIVENESS_PROBE_FLAG" ]; then echo "liveness_probe_flag=$LIVENESS_PROBE_FLAG" >> $GITHUB_OUTPUT; fi
            fi

            # Write all service-level config values to GITHUB_OUTPUT with sanitization
            # to prevent any invalid format issues
            write_to_output() {
              local key=$1
              local value=$2
              # Clean value: remove leading/trailing spaces, carriage returns, and newlines
              value=$(echo "$value" | sed 's/^ *//;s/ *$//;s/\r//g' | tr -d '\n')
              echo "[DEBUG] About to write to GITHUB_OUTPUT: $key='$value'"
              if [ -n "$value" ]; then
                # Skip if value contains '='
                if echo "$value" | grep -q '='; then
                  echo "[ERROR] Value for $key contains '=': $value" >&2
                else
                  echo "$key=$value" >> $GITHUB_OUTPUT
                fi
              fi
            }
            
            write_to_output "service_name" "$SERVICE_NAME"
            write_to_output "memory" "$MEMORY"
            write_to_output "cpu" "$CPU"
            write_to_output "concurrency" "$CONCURRENCY"
            write_to_output "timeout" "$TIMEOUT"
            write_to_output "min_instances" "$MIN_INSTANCES"
            write_to_output "max_instances" "$MAX_INSTANCES"
            write_to_output "allow_unauth" "$ALLOW_UNAUTH"
            write_to_output "vpc_connector" "$VPC_CONNECTOR"
            write_to_output "has_config" "true"

            # Print the content of $GITHUB_OUTPUT for debugging
            echo "----- BEGIN GITHUB_OUTPUT CONTENTS -----"
            cat $GITHUB_OUTPUT || echo "Failed to read GITHUB_OUTPUT"
            echo "----- END GITHUB_OUTPUT CONTENTS -----"
          else
            echo "Config file not found: ${{ inputs.config_file }}"
            exit 1
          fi

      - name: Set service name
        id: set-service-name
        run: |
          if [ "${{ inputs.config_file != '' }}" == "true" ] && [ "${{ steps.read-config.outputs.has_config }}" == "true" ]; then
            if [ "${{ github.event_name }}" = "pull_request" ]; then
              echo "final_service_name=${{ steps.read-config.outputs.service_name }}-${{ github.event.number }}" >> $GITHUB_OUTPUT
            else
              echo "final_service_name=${{ steps.read-config.outputs.service_name }}" >> $GITHUB_OUTPUT
            fi
          else
            echo "final_service_name=${{ inputs.service_name }}" >> $GITHUB_OUTPUT
          fi

      - name: Generate deployment flags
        id: generate-flags
        run: |
          FLAGS=""
          
          # Add resource flags if config file is used
          if [ "${{ inputs.config_file != '' }}" == "true" ] && [ "${{ steps.read-config.outputs.has_config }}" == "true" ]; then
            FLAGS="$FLAGS --memory=${{ steps.read-config.outputs.memory }}"
            FLAGS="$FLAGS --cpu=${{ steps.read-config.outputs.cpu }}"
            FLAGS="$FLAGS --concurrency=${{ steps.read-config.outputs.concurrency }}"
            FLAGS="$FLAGS --timeout=${{ steps.read-config.outputs.timeout }}s"
            FLAGS="$FLAGS --min-instances=${{ steps.read-config.outputs.min_instances }}"
            FLAGS="$FLAGS --max-instances=${{ steps.read-config.outputs.max_instances }}"
            
            # Add VPC connector if specified
            if [ "${{ steps.read-config.outputs.vpc_connector }}" != "" ]; then
              FLAGS="$FLAGS --vpc-connector=${{ steps.read-config.outputs.vpc_connector }}"
            fi
            
            # Auth settings from config
            if [ "${{ steps.read-config.outputs.allow_unauth }}" == "true" ]; then
              FLAGS="$FLAGS --allow-unauthenticated"
            fi

            # Check if this is a multi-container deployment
            if [ "${{ steps.read-config.outputs.is_multi_container }}" == "true" ]; then
              # Add container configuration for multi-container
              # Add each flag separately, properly escaped where needed
              if [ -n "${{ steps.read-config.outputs.containers_config }}" ]; then
                FLAGS="$FLAGS ${{ steps.read-config.outputs.containers_config }}"
              fi
              if [ -n "${{ steps.read-config.outputs.containers_args }}" ]; then
                # Make sure args with spaces are properly quoted
                FLAGS="$FLAGS ${{ steps.read-config.outputs.containers_args }}"
              fi
              if [ -n "${{ steps.read-config.outputs.containers_env }}" ]; then
                FLAGS="$FLAGS ${{ steps.read-config.outputs.containers_env }}"
              fi
              if [ -n "${{ steps.read-config.outputs.containers_image }}" ]; then
                FLAGS="$FLAGS ${{ steps.read-config.outputs.containers_image }}"
              fi
              if [ -n "${{ steps.read-config.outputs.containers_memory }}" ]; then
                FLAGS="$FLAGS ${{ steps.read-config.outputs.containers_memory }}"
              fi
              if [ -n "${{ steps.read-config.outputs.containers_cpu }}" ]; then
                FLAGS="$FLAGS ${{ steps.read-config.outputs.containers_cpu }}"
              fi
              if [ -n "${{ steps.read-config.outputs.containers_port }}" ]; then
                FLAGS="$FLAGS ${{ steps.read-config.outputs.containers_port }}"
              fi
            else
              # Add environment variables
              ENV_VARS="${{ steps.read-config.outputs.env_vars }}"
              # Add APP_CONFIG_FILE_B64 if present
              if [ "${{ steps.read-config.outputs.app_config_file_b64 }}" != "" ]; then
                if [ "$ENV_VARS" != "--set-env-vars=" ] && [ "$ENV_VARS" != "" ]; then
                  ENV_VARS="$ENV_VARS,APP_CONFIG_FILE_B64=${{ steps.read-config.outputs.app_config_file_b64 }}"
                else
                  ENV_VARS="--set-env-vars=APP_CONFIG_FILE_B64=${{ steps.read-config.outputs.app_config_file_b64 }}"
                fi
              fi
              # Add SIDECAR_CONFIG_FILE_B64 if present
              if [ "${{ steps.read-config.outputs.sidecar_config_file_b64 }}" != "" ]; then
                if [ "$ENV_VARS" != "--set-env-vars=" ] && [ "$ENV_VARS" != "" ]; then
                  ENV_VARS="$ENV_VARS,SIDECAR_CONFIG_B64=${{ steps.read-config.outputs.sidecar_config_file_b64 }}"
                else
                  ENV_VARS="--set-env-vars=SIDECAR_CONFIG_B64=${{ steps.read-config.outputs.sidecar_config_file_b64 }}"
                fi
              fi
              FLAGS="$FLAGS $ENV_VARS"

              # Add custom command and args if present
              if [ "${{ steps.read-config.outputs.command }}" != "" ]; then
                FLAGS="$FLAGS --command=${{ steps.read-config.outputs.command }}"
              fi
              if [ "${{ steps.read-config.outputs.args }}" != "" ]; then
                FLAGS="$FLAGS --args=\"${{ steps.read-config.outputs.args }}\""
              fi
            fi
            
            # Add health check probe flags if present
            if [ "${{ steps.read-config.outputs.startup_probe_flag }}" != "" ]; then
              FLAGS="$FLAGS ${{ steps.read-config.outputs.startup_probe_flag }}"
            fi
            if [ "${{ steps.read-config.outputs.liveness_probe_flag }}" != "" ]; then
              FLAGS="$FLAGS ${{ steps.read-config.outputs.liveness_probe_flag }}"
            fi
            
            # Add port flag if specified in config
            if [ "${{ steps.read-config.outputs.port }}" != "" ]; then
              FLAGS="$FLAGS --port=${{ steps.read-config.outputs.port }}"
            fi
            
          else
            # Auth settings from input
            if [ "${{ inputs.allow_unauth }}" == "true" ]; then
              FLAGS="$FLAGS --allow-unauthenticated"
            fi
          fi
          
          echo "flags=$FLAGS" >> $GITHUB_OUTPUT

      - name: Print deployment flags
        run: |
          echo "Deploying with the following flags:"
          echo "Service: ${{ steps.set-service-name.outputs.final_service_name }}"
          echo "Region: ${{ inputs.region }}"
          echo "Image: ${{ inputs.image_tag }}"
          echo "Project ID: ${{ inputs.gcp_project_id }}"
          echo "Flags: ${{ steps.generate-flags.outputs.flags }}"

      - name: Deploy to Cloud Run
        id: deploy
        uses: google-github-actions/deploy-cloudrun@v2
        with:
          service: ${{ steps.set-service-name.outputs.final_service_name }}
          region: ${{ inputs.region }}
          image: ${{ inputs.image_tag }}
          flags: ${{ steps.generate-flags.outputs.flags }}
          project_id: ${{ inputs.gcp_project_id }}

      - name: Get Cloud Run Service URL
        id: get-url
        run: |
          URL=$(gcloud run services describe ${{ steps.set-service-name.outputs.final_service_name }} --platform managed --project ${{ inputs.gcp_project_id }} --region ${{ inputs.region }} --format 'value(status.url)')
          echo "url=$URL" >> $GITHUB_OUTPUT

      - name: Print GITHUB_OUTPUT file
        if: always()
        run: cat $GITHUB_OUTPUT || true
