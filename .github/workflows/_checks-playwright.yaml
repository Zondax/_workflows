name: Playwright Tests
on:
  workflow_call:
    inputs:
      working_directory:
        description: "Working directory for tests"
        type: string
        default: "."
      build_command:
        description: "Build command to run before tests (without package manager prefix)"
        type: string
        default: "test:e2e:build"
      test_command:
        description: "Command to run Playwright tests (without package manager prefix)"
        type: string
        default: "test:e2e:sharding"
      install_command:
        description: "Command to install Playwright browsers (without package manager prefix)"
        type: string
        default: "playwright install --with-deps"
      env_init_command:
        description: "Command to initialize environment (without package manager prefix)"
        type: string
        default: "env:init:ci"
      runner:
        description: "GitHub runner to use"
        type: string
        default: "zondax-runners"
      base_image:
        description: "Docker image to use"
        type: string
        default: "zondax/ubuntu-ci:22.04"
      use_env_local:
        description: "Whether to use the environment local file provided in secrets"
        type: boolean
        required: false
        default: true
      checkout_submodules:
        description: "Checkout submodules"
        required: false
        type: boolean
        default: true
      github_app_auth:
        description: "Use GitHub App Token"
        required: false
        type: boolean
        default: false
      github_app_repos:
        description: "Additional repositories to access (one per line)"
        required: false
        type: string
        default: ""
      autoinit_env:
        description: "Automatically run env:init:ci script after installing dependencies"
        required: false
        type: boolean
        default: false
      environment:
        description: "Environment name to use for accessing environment variables"
        required: false
        type: string
        default: ""
      timeout_minutes:
        description: "Timeout in minutes for the job"
        type: number
        default: 30
      use_sccache:
        description: "Enable sccache for Rust compilation caching"
        type: boolean
        default: false
      sccache_bucket:
        description: "S3-compatible bucket name for sccache (e.g., Cloudflare R2)"
        type: string
        default: ""
      sccache_endpoint:
        description: "S3-compatible endpoint URL for sccache"
        type: string
        default: ""
      sccache_region:
        description: "S3 region for sccache"
        type: string
        default: "auto"
      sccache_use_ssl:
        description: "Use SSL/TLS for sccache S3 connection (set true for HTTPS endpoints)"
        type: boolean
        default: true
      system_deps_command:
        description: "Command to install system dependencies (e.g., 'apt-get update && apt-get install -y ...')"
        type: string
        default: ""
      enable_nextjs_cache:
        description: "Enable Next.js build cache (only for Next.js projects)"
        type: boolean
        default: false
      nextjs_cache_paths:
        description: "Path(s) to Next.js cache directories. Use newlines for multiple paths in monorepos."
        type: string
        default: ".next/cache"
      # Custom environment variables for test configuration
      extra_env:
        description: "Additional environment variables (KEY=VALUE format, one per line)"
        type: string
        default: ""
      # Playwright test filtering options
      playwright_project:
        description: "Playwright project to run (e.g., 'chromium', 'webkit'). If empty, runs all projects."
        type: string
        default: ""
      playwright_grep:
        description: "Grep pattern to filter tests (e.g., '@smoke', '@integration'). Passed to --grep flag."
        type: string
        default: ""
      disable_sharding:
        description: "Disable sharding and run all tests in a single job. Useful for tests that require isolation."
        type: boolean
        default: false
    secrets:
      env_local:
        description: "Env local file to set environment variables (one export per line)"
        required: false
      app_id:
        description: "GitHub App ID"
        required: false
      app_pem:
        description: "GitHub App PEM"
        required: false
      sccache_access_key_id:
        description: "AWS/S3 access key ID for sccache backend"
        required: false
      sccache_secret_access_key:
        description: "AWS/S3 secret access key for sccache backend"
        required: false

jobs:
  playwright:
    name: Playwright ${{ inputs.disable_sharding && 'Tests' || 'Shard' }}
    runs-on: ${{ inputs.runner }}
    strategy:
      fail-fast: false
      matrix:
        include: ${{ inputs.disable_sharding && fromJson('[{"position":"single","playwrightShard":""}]') || fromJson('[{"position":"shard1","playwrightShard":"1/2"},{"position":"shard2","playwrightShard":"2/2"}]') }}
    container:
      image: ${{ inputs.base_image }}
      env:
        DOCKER_HOST: unix:///var/run/docker/docker.sock
        PLAYWRIGHT_SHARD: ${{ matrix.playwrightShard }}
        CI: true
        HEAD_SHA: ${{ github.event.pull_request.head.sha }}
        HEAD_BRANCH_NAME: ${{ github.head_ref }}
        # Tauri-specific (ignored by web tests)
        DISPLAY: ':99'
        GDK_BACKEND: 'x11'
        BACKEND_TIMEOUT: '240000'
      volumes:
        - /var/run/docker/docker.sock:/var/run/docker/docker.sock
    environment: ${{ inputs.environment }}
    timeout-minutes: ${{ inputs.timeout_minutes }}
    env:
      # CI metadata
      HEAD_SHA: ${{ github.event.pull_request.head.sha }}
      HEAD_BRANCH_NAME: ${{ github.head_ref }}

      # sccache S3-compatible backend configuration (only if enabled)
      SCCACHE_BUCKET: ${{ inputs.use_sccache && inputs.sccache_bucket || '' }}
      SCCACHE_ENDPOINT: ${{ inputs.use_sccache && inputs.sccache_endpoint || '' }}
      SCCACHE_REGION: ${{ inputs.use_sccache && inputs.sccache_region || 'auto' }}
      SCCACHE_S3_USE_SSL: ${{ inputs.use_sccache && inputs.sccache_use_ssl && 'true' || 'false' }}
      SCCACHE_CACHE_SIZE: 100G
      AWS_ACCESS_KEY_ID: ${{ inputs.use_sccache && secrets.sccache_access_key_id || '' }}
      AWS_SECRET_ACCESS_KEY: ${{ inputs.use_sccache && secrets.sccache_secret_access_key || '' }}
    permissions:
      contents: read
      id-token: write  # Required for Workload Identity Federation
    steps:
      - name: Setup Ubuntu packages
        # Only needed when not using zondax/ubuntu-ci base image
        if: ${{ !startsWith(inputs.base_image, 'zondax/ubuntu-ci') }}
        uses: zondax/actions/setup-ubuntu-packages@v1
        with:
          packages: |
            - git
            - jq
            - libnss3
            - libnspr4
            - libdbus-1-3
            - libatk1.0-0t64
            - libatk-bridge2.0-0t64
            - libatspi2.0-0t64
            - libxcomposite1
            - libxdamage1
            - libxfixes3
            - libxrandr2
            - libgbm1
            - libxkbcommon0
            - libasound2t64

      - name: Checkout with GitHub App
        uses: zondax/actions/checkout-with-app@v1
        with:
          github_app_auth: ${{ inputs.github_app_auth }}
          github_app_repos: ${{ inputs.github_app_repos }}
          checkout_submodules: ${{ inputs.checkout_submodules }}
          app_id: ${{ secrets.app_id }}
          app_pem: ${{ secrets.app_pem }}

      - name: Set extra environment variables
        if: inputs.extra_env != ''
        shell: bash
        run: |
          echo "${{ inputs.extra_env }}" | while IFS= read -r line; do
            if [ -n "$line" ] && [[ "$line" == *"="* ]]; then
              echo "$line" >> $GITHUB_ENV
              echo "Set env: ${line%%=*}"
            fi
          done

      - name: Check for cache control in PR title
        id: cache-control
        shell: bash
        run: |
          PR_TITLE="${{ github.event.pull_request.title }}"
          if echo "$PR_TITLE" | grep -qiE '\[no[_-]?cache\]|\[cache[_-]?off\]'; then
            echo "Cache disabled via PR title"
            echo "enabled=false" >> $GITHUB_OUTPUT
          else
            echo "enabled=true" >> $GITHUB_OUTPUT
          fi

      - name: Authenticate with GCP
        if: ${{ inputs.autoinit_env && inputs.environment != '' }}
        uses: zondax/actions/gcp-wif-auth@v1
        with:
          workload_identity_provider: ${{ vars.PULUMI_FRONTEND_WIF_PROVIDER }}
          project_id: ${{ vars.PULUMI_GCP_PROJECT_ID }}

      - name: Setup environment variables
        if: inputs.use_env_local
        run: |
          # Create .env.local file directly for Next.js
          cd ${{ inputs.working_directory }}
          cat > .env.local << 'EOL'
          # Environment variables for Next.js
          ${{ secrets.env_local }}
          EOL

          # Show confirmation (only count lines for security)
          echo "Created .env.local file with $(grep -c "=" .env.local) environment variables"

      - name: Cache Cargo registry
        if: inputs.use_sccache && inputs.sccache_bucket != '' && steps.cache-control.outputs.enabled != 'false'
        uses: runs-on/cache@v4
        env:
          RUNS_ON_S3_BUCKET_CACHE: ${{ inputs.sccache_bucket }}
          RUNS_ON_S3_FORCE_PATH_STYLE: "true"
          AWS_ACCESS_KEY_ID: ${{ secrets.sccache_access_key_id }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.sccache_secret_access_key }}
          AWS_ENDPOINT_URL: ${{ inputs.sccache_endpoint }}
          AWS_REGION: ${{ inputs.sccache_region }}
        with:
          path: |
            ~/.cargo/registry/index
            ~/.cargo/registry/cache
            ~/.cargo/git/db
          key: ${{ runner.os }}-cargo-${{ github.ref_name }}
          restore-keys: |
            ${{ runner.os }}-cargo-main
            ${{ runner.os }}-cargo-dev
            ${{ runner.os }}-cargo-

      - name: Cache Next.js build
        if: inputs.enable_nextjs_cache && inputs.sccache_bucket != '' && steps.cache-control.outputs.enabled != 'false'
        uses: runs-on/cache@v4
        env:
          RUNS_ON_S3_BUCKET_CACHE: ${{ inputs.sccache_bucket }}
          RUNS_ON_S3_FORCE_PATH_STYLE: "true"
          AWS_ACCESS_KEY_ID: ${{ secrets.sccache_access_key_id }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.sccache_secret_access_key }}
          AWS_ENDPOINT_URL: ${{ inputs.sccache_endpoint }}
          AWS_REGION: ${{ inputs.sccache_region }}
        with:
          path: ${{ inputs.nextjs_cache_paths }}
          key: ${{ runner.os }}-nextjs-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-nextjs-

      - name: Setup mise
        uses: jdx/mise-action@v3
        with:
          install: true
          cache: false
          working_directory: ${{ inputs.working_directory }}

      - name: Detect package manager
        id: pm
        working-directory: ${{ inputs.working_directory }}
        run: |
          if mise tasks --no-header 2>/dev/null | grep -q "^ci_detect_pm"; then
            echo "$(mise run ci_detect_pm)" >> $GITHUB_OUTPUT
          else
            # Default detection
            if [ -f "bun.lockb" ] || [ -f "bun.lock" ]; then
              echo "pm=bun" >> $GITHUB_OUTPUT
              echo "pm_name=bun" >> $GITHUB_OUTPUT
            elif [ -f "pnpm-lock.yaml" ]; then
              echo "pm=pnpm run" >> $GITHUB_OUTPUT
              echo "pm_name=pnpm" >> $GITHUB_OUTPUT
            elif [ -f "yarn.lock" ]; then
              echo "pm=yarn run" >> $GITHUB_OUTPUT
              echo "pm_name=yarn" >> $GITHUB_OUTPUT
            elif [ -f "package-lock.json" ]; then
              echo "pm=npm run" >> $GITHUB_OUTPUT
              echo "pm_name=npm" >> $GITHUB_OUTPUT
            else
              echo "Error: Could not detect package manager. No lock file found (bun.lockb, bun.lock, pnpm-lock.yaml, yarn.lock, or package-lock.json)."
              echo "Either add a lock file or define a 'ci_detect_pm' mise task to specify the package manager."
              exit 1
            fi
          fi

      - name: Get pnpm store directory
        if: inputs.sccache_bucket != '' && steps.pm.outputs.pm_name == 'pnpm'
        id: pnpm-cache
        working-directory: ${{ inputs.working_directory }}
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path)" >> $GITHUB_OUTPUT

      - name: Cache pnpm store
        if: inputs.sccache_bucket != '' && steps.pm.outputs.pm_name == 'pnpm' && steps.pnpm-cache.outputs.STORE_PATH != '' && steps.cache-control.outputs.enabled != 'false'
        uses: runs-on/cache@v4
        env:
          RUNS_ON_S3_BUCKET_CACHE: ${{ inputs.sccache_bucket }}
          RUNS_ON_S3_FORCE_PATH_STYLE: "true"
          AWS_ACCESS_KEY_ID: ${{ secrets.sccache_access_key_id }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.sccache_secret_access_key }}
          AWS_ENDPOINT_URL: ${{ inputs.sccache_endpoint }}
          AWS_REGION: ${{ inputs.sccache_region }}
        with:
          path: ${{ steps.pnpm-cache.outputs.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-${{ github.ref_name }}
          restore-keys: |
            ${{ runner.os }}-pnpm-main
            ${{ runner.os }}-pnpm-dev
            ${{ runner.os }}-pnpm-

      - name: Cache Bun dependencies
        if: inputs.sccache_bucket != '' && steps.pm.outputs.pm_name == 'bun' && steps.cache-control.outputs.enabled != 'false'
        uses: runs-on/cache@v4
        env:
          RUNS_ON_S3_BUCKET_CACHE: ${{ inputs.sccache_bucket }}
          RUNS_ON_S3_FORCE_PATH_STYLE: "true"
          AWS_ACCESS_KEY_ID: ${{ secrets.sccache_access_key_id }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.sccache_secret_access_key }}
          AWS_ENDPOINT_URL: ${{ inputs.sccache_endpoint }}
          AWS_REGION: ${{ inputs.sccache_region }}
        with:
          path: ~/.bun/install/cache
          key: ${{ runner.os }}-bun-${{ hashFiles('bun.lockb', 'bun.lock') }}
          restore-keys: |
            ${{ runner.os }}-bun-

      - name: Run ci_postinstall
        working-directory: ${{ inputs.working_directory }}
        run: |
          if mise tasks --no-header 2>/dev/null | grep -q "^ci_postinstall"; then
            mise run ci_postinstall
          fi

      - name: Setup sccache
        if: inputs.use_sccache
        uses: mozilla-actions/sccache-action@v0.0.9

      - name: Install system dependencies
        if: inputs.system_deps_command != ''
        working-directory: ${{ inputs.working_directory }}
        run: ${{ inputs.system_deps_command }}

      - name: Initialize environment
        if: ${{ inputs.autoinit_env }}
        working-directory: ${{ inputs.working_directory }}
        run: ${{ steps.pm.outputs.pm }} ${{ inputs.env_init_command }}

      - name: Run build
        working-directory: ${{ inputs.working_directory }}
        run: ${{ steps.pm.outputs.pm }} ${{ inputs.build_command }}

      - name: Install Playwright browsers
        working-directory: ${{ inputs.working_directory }}
        run: npx ${{ inputs.install_command }}

      - name: Verify shard configuration
        working-directory: ${{ inputs.working_directory }}
        run: |
          echo "=== Playwright Configuration ==="
          echo "Sharding: ${{ inputs.disable_sharding && 'DISABLED' || 'ENABLED' }}"
          echo "Current shard: ${PLAYWRIGHT_SHARD:-'N/A (sharding disabled)'}"
          echo "Project filter: ${{ inputs.playwright_project || 'all projects' }}"
          echo "Grep filter: ${{ inputs.playwright_grep || 'none' }}"
          echo ""
          echo "Listing tests:"
          SHARD_ARG=""
          PROJECT_ARG=""
          GREP_ARG=""
          if [ -n "$PLAYWRIGHT_SHARD" ]; then
            SHARD_ARG="--shard=$PLAYWRIGHT_SHARD"
          fi
          if [ -n "${{ inputs.playwright_project }}" ]; then
            PROJECT_ARG="--project=${{ inputs.playwright_project }}"
          fi
          if [ -n "${{ inputs.playwright_grep }}" ]; then
            GREP_ARG="--grep=\"${{ inputs.playwright_grep }}\""
          fi
          eval "npx playwright test --list $SHARD_ARG $PROJECT_ARG $GREP_ARG" || echo "Note: Test listing may not be available in all configurations"

      - name: Run Playwright tests
        working-directory: ${{ inputs.working_directory }}
        env:
          KIND_EXPERIMENTAL_DOCKER_NETWORK: ${{ job.container.network }}
          RUSTC_WRAPPER: ${{ inputs.use_sccache && 'sccache' || '' }}
          SCCACHE_GHA_ENABLED: ${{ inputs.use_sccache && 'true' || '' }}
          CARGO_INCREMENTAL: ${{ inputs.use_sccache && '0' || '' }}
          # Pass project and grep filters via env vars for the test command to use
          PLAYWRIGHT_PROJECT: ${{ inputs.playwright_project }}
          PLAYWRIGHT_GREP: ${{ inputs.playwright_grep }}
        run: |
          # Build the test command with optional flags
          CMD="${{ steps.pm.outputs.pm }} ${{ inputs.test_command }}"
          if [ -n "$PLAYWRIGHT_PROJECT" ]; then
            CMD="$CMD --project=\"$PLAYWRIGHT_PROJECT\""
          fi
          if [ -n "$PLAYWRIGHT_GREP" ]; then
            CMD="$CMD --grep=\"$PLAYWRIGHT_GREP\""
          fi
          echo "Running: $CMD"
          eval $CMD

      - name: Cleanup xvfb and Tauri processes
        if: always()
        run: |
          pkill -9 Xvfb || true
          pkill -9 tauri || true
          echo "Cleanup complete"

      - name: Upload Playwright Report
        if: ${{ !cancelled() }}
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report-${{ matrix.position }}
          path: ${{ inputs.working_directory }}/playwright-report/
          retention-days: 15

      - name: Write job summary
        if: always()
        run: |
          # Build job identifier
          if [ -n "${{ matrix.playwrightShard }}" ]; then
            JOB_ID="Shard ${{ matrix.playwrightShard }}"
          else
            JOB_ID="Tests"
          fi

          if [ "${{ job.status }}" == "success" ]; then
            echo "## ðŸŽ­ Playwright $JOB_ID âœ…" >> $GITHUB_STEP_SUMMARY
            echo "All tests passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "## ðŸŽ­ Playwright $JOB_ID âŒ" >> $GITHUB_STEP_SUMMARY
            echo "Some tests failed - check logs for details" >> $GITHUB_STEP_SUMMARY
          fi
