name: Reusable Rust Checks

on:
  workflow_call:
    inputs:
      enable_linting:
        description: "Enable linting checks with clippy"
        required: false
        type: boolean
        default: true
      enable_tests:
        description: "Enable tests execution"
        required: false
        type: boolean
        default: true
      enable_coverage:
        description: "Enable test coverage reporting"
        required: false
        type: boolean
        default: true
      coverage_threshold:
        description: "Minimum coverage percentage required"
        required: false
        type: number
        default: 75
      coverage_artifact_suffix:
        description: "Suffix to append to coverage artifact name for uniqueness (e.g., 'linux', 'macos')"
        required: false
        type: string
        default: ""
      runner_preset:
        description: "Runner preset (linux-amd64, macos-arm64)"
        required: false
        type: string
        default: "linux-amd64"
      base_image:
        description: "Docker image to use (zondax/ubuntu-ci includes node, bun, pnpm, rust)"
        required: false
        type: string
        default: "zondax/ubuntu-ci:22.04"
      package_path:
        description: "Path to the Rust package relative to the repository root"
        required: false
        type: string
        default: "."
      test_args:
        description: "Additional arguments to pass to cargo test"
        required: false
        type: string
        default: ""
      timeout_minutes:
        description: "Timeout in minutes for the job"
        type: number
        default: 10
      checkout_submodules:
        description: "Checkout submodules"
        required: false
        type: boolean
        default: true
      github_app_auth:
        description: "Use GitHub App Token"
        required: false
        type: boolean
        default: false
      github_app_repos:
        description: "Additional repositories to access (one per line)"
        required: false
        type: string
        default: ""
      post_pr_comment:
        description: "Post coverage results as PR comment"
        required: false
        type: boolean
        default: true
      enable_security_audit:
        description: "Enable security audit with cargo audit"
        required: false
        type: boolean
        default: true
      enable_build:
        description: "Enable build step"
        required: false
        type: boolean
        default: true
      cache_cargo:
        description: "Enable Cargo caching"
        required: false
        type: boolean
        default: true
      enable_node:
        description: "Enable Node.js package manager support"
        required: false
        type: boolean
        default: false
      test_command:
        description: "Test command to run"
        required: false
        type: string
        default: "cargo test --all-features"
      lint_command:
        description: "Lint command to run"
        required: false
        type: string
        default: "cargo clippy --all-targets --all-features -- -D warnings"
      format_command:
        description: "Format check command to run"
        required: false
        type: string
        default: "cargo fmt --all -- --check"
      coverage_command:
        description: "Coverage command to run"
        required: false
        type: string
        default: "cargo tarpaulin --all-features --out Json --output-dir ."
      build_command:
        description: "Build command to run"
        required: false
        type: string
        default: "cargo build --all-targets --all-features"
      audit_command:
        description: "Security audit command to run"
        required: false
        type: string
        default: "cargo audit"
      system_deps_command:
        description: "Command to install system dependencies (e.g., 'apt-get update && apt-get install -y sccache')"
        required: false
        type: string
        default: ""
      environment:
        description: "Environment name to use for accessing environment variables"
        type: string
        default: ""
      autoinit_env:
        description: "Automatically run env:init:ci script after installing dependencies"
        type: boolean
        default: false
      env_init_command:
        description: "Command to initialize environment (without package manager prefix)"
        type: string
        default: "env:init:ci"
      use_sccache:
        description: "Enable sccache for Rust compilation caching"
        type: boolean
        default: false
      sccache_bucket:
        description: "S3-compatible bucket name for sccache (e.g., Cloudflare R2)"
        type: string
        default: ""
      sccache_endpoint:
        description: "S3-compatible endpoint URL for sccache"
        type: string
        default: ""
      sccache_region:
        description: "S3 region for sccache"
        type: string
        default: "auto"
      sccache_use_ssl:
        description: "Use SSL/TLS for sccache S3 connection (set true for HTTPS endpoints)"
        type: boolean
        default: true
      enable_integration_tests:
        description: "Enable integration tests (TypeScript client vs Rust server)"
        type: boolean
        default: false
      integration_test_command:
        description: "Integration test command to run (requires enable_node: true)"
        type: string
        default: "pnpm test:integration"
      integration_build_command:
        description: "Command to build test binaries before integration tests"
        type: string
        default: ""
    secrets:
      app_id:
        description: "GitHub App ID"
        required: false
      app_pem:
        description: "GitHub App PEM"
        required: false
      sccache_access_key_id:
        description: "AWS/S3 access key ID for sccache backend"
        required: false
      sccache_secret_access_key:
        description: "AWS/S3 secret access key for sccache backend"
        required: false

permissions:
  contents: read
  pull-requests: write

jobs:
  checks-rust:
    runs-on: ${{ fromJSON(inputs.runner_preset == 'macos-arm64' && '["self-hosted", "macOS", "ARM64"]' || inputs.runner_preset == 'linux-amd64' && '["zondax-runners"]' || '["zondax-runners"]') }}
    container: ${{ inputs.runner_preset == 'linux-amd64' && inputs.base_image || '' }}
    timeout-minutes: ${{ inputs.timeout_minutes }}
    environment: ${{ inputs.environment }}
    env:
      # sccache S3-compatible backend configuration (only if enabled)
      SCCACHE_BUCKET: ${{ inputs.use_sccache && inputs.sccache_bucket || '' }}
      SCCACHE_ENDPOINT: ${{ inputs.use_sccache && inputs.sccache_endpoint || '' }}
      SCCACHE_REGION: ${{ inputs.use_sccache && inputs.sccache_region || 'auto' }}
      SCCACHE_S3_USE_SSL: ${{ inputs.use_sccache && inputs.sccache_use_ssl && 'true' || 'false' }}
      SCCACHE_CACHE_SIZE: 100G
      AWS_ACCESS_KEY_ID: ${{ inputs.use_sccache && secrets.sccache_access_key_id || '' }}
      AWS_SECRET_ACCESS_KEY: ${{ inputs.use_sccache && secrets.sccache_secret_access_key || '' }}
    defaults:
      run:
        working-directory: ${{ inputs.package_path }}
    permissions:
      contents: read
      id-token: write
    outputs:
      coverage_percentage: ${{ steps.coverage-check.outputs.coverage_percentage }}
      coverage_status: ${{ steps.coverage-check.outputs.coverage_status }}
      coverage_message: ${{ steps.coverage-check.outputs.coverage_message }}
      
    steps:
      - name: Setup Ubuntu packages
        # Skip when using zondax/ubuntu-ci (packages pre-installed, but sudo available if needed)
        if: inputs.runner_preset == 'linux-amd64' && !startsWith(inputs.base_image, 'zondax/ubuntu-ci')
        uses: zondax/actions/setup-ubuntu-packages@v1
        with:
          packages: |
            - git
            - curl
            - build-essential
            - pkg-config
            - libssl-dev
      
      - name: Checkout with GitHub App
        uses: zondax/actions/checkout-with-app@v1
        with:
          github_app_auth: ${{ inputs.github_app_auth }}
          github_app_repos: ${{ inputs.github_app_repos }}
          checkout_submodules: ${{ inputs.checkout_submodules }}
          ref: ${{ github.event.pull_request.head.sha }}
          app_id: ${{ secrets.app_id }}
          app_pem: ${{ secrets.app_pem }}

      - name: Check for cache control in PR title
        id: cache-control
        shell: bash
        run: |
          PR_TITLE="${{ github.event.pull_request.title }}"
          if echo "$PR_TITLE" | grep -qiE '\[no[_-]?cache\]|\[cache[_-]?off\]'; then
            echo "Cache disabled via PR title"
            echo "enabled=false" >> $GITHUB_OUTPUT
          else
            echo "enabled=true" >> $GITHUB_OUTPUT
          fi

      - name: Authenticate with GCP
        if: ${{ inputs.autoinit_env && inputs.environment != '' }}
        uses: zondax/actions/gcp-wif-auth@v1
        with:
          workload_identity_provider: ${{ vars.PULUMI_FRONTEND_WIF_PROVIDER }}
          project_id: ${{ vars.PULUMI_GCP_PROJECT_ID }}

      - name: Cache Cargo registry
        if: inputs.sccache_bucket != '' && steps.cache-control.outputs.enabled != 'false'
        uses: runs-on/cache@v4
        env:
          RUNS_ON_S3_BUCKET_CACHE: ${{ inputs.sccache_bucket }}
          RUNS_ON_S3_FORCE_PATH_STYLE: "true"
          AWS_ACCESS_KEY_ID: ${{ secrets.sccache_access_key_id }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.sccache_secret_access_key }}
          AWS_ENDPOINT_URL: ${{ inputs.sccache_endpoint }}
          AWS_REGION: ${{ inputs.sccache_region }}
        with:
          path: |
            ~/.cargo/registry/index
            ~/.cargo/registry/cache
            ~/.cargo/git/db
          key: ${{ runner.os }}-cargo-${{ github.ref_name }}
          restore-keys: |
            ${{ runner.os }}-cargo-main
            ${{ runner.os }}-cargo-dev
            ${{ runner.os }}-cargo-

      - name: Setup mise
        uses: jdx/mise-action@v3
        with:
          install: true
          cache: false
          working_directory: ${{ inputs.package_path }}

      - name: Run ci_postinstall
        working-directory: ${{ inputs.package_path }}
        run: |
          if mise tasks --no-header 2>/dev/null | grep -q "^ci_postinstall"; then
            mise run ci_postinstall
          fi

      - name: Detect package manager
        id: pm
        working-directory: ${{ inputs.package_path }}
        run: |
          if mise tasks --no-header 2>/dev/null | grep -q "^ci_detect_pm"; then
            echo "$(mise run ci_detect_pm)" >> $GITHUB_OUTPUT
          else
            # Default detection
            if [ -f "bun.lockb" ] || [ -f "bun.lock" ]; then
              echo "pm=bun" >> $GITHUB_OUTPUT
            elif [ -f "pnpm-lock.yaml" ]; then
              echo "pm=pnpm run" >> $GITHUB_OUTPUT
            elif [ -f "yarn.lock" ]; then
              echo "pm=yarn run" >> $GITHUB_OUTPUT
            elif [ -f "package-lock.json" ]; then
              echo "pm=npm run" >> $GITHUB_OUTPUT
            else
              echo "Error: Could not detect package manager. No lock file found (bun.lockb, bun.lock, pnpm-lock.yaml, yarn.lock, or package-lock.json)."
              echo "Either add a lock file or define a 'ci_detect_pm' mise task to specify the package manager."
              exit 1
            fi
          fi

      - name: Initialize environment
        if: ${{ inputs.autoinit_env }}
        working-directory: ${{ inputs.package_path }}
        run: ${{ steps.pm.outputs.pm }} ${{ inputs.env_init_command }}

      - name: Setup sccache
        if: inputs.use_sccache
        uses: mozilla-actions/sccache-action@v0.0.9

      - name: Setup Rust cache
        if: inputs.cache_cargo && !inputs.use_sccache && steps.cache-control.outputs.enabled != 'false'
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: ${{ inputs.package_path }}
          cache-on-failure: true

      - name: Install cargo-tarpaulin for coverage
        if: inputs.enable_coverage
        uses: taiki-e/install-action@v2
        with:
          tool: cargo-tarpaulin

      - name: Install cargo-audit for security
        if: inputs.enable_security_audit
        uses: taiki-e/install-action@v2
        with:
          tool: cargo-audit

      - name: Install cargo-deny for security
        if: inputs.enable_security_audit
        uses: taiki-e/install-action@v2
        with:
          tool: cargo-deny

      - name: Install system dependencies
        if: inputs.system_deps_command != ''
        run: ${{ inputs.system_deps_command }}

      - name: Check formatting
        env:
          RUSTC_WRAPPER: ${{ inputs.use_sccache && 'sccache' || '' }}
          SCCACHE_GHA_ENABLED: ${{ inputs.use_sccache && 'true' || '' }}
          CARGO_INCREMENTAL: ${{ inputs.use_sccache && '0' || '' }}
        run: ${{ inputs.format_command }}

      - name: Build
        if: inputs.enable_build
        env:
          RUSTC_WRAPPER: ${{ inputs.use_sccache && 'sccache' || '' }}
          SCCACHE_GHA_ENABLED: ${{ inputs.use_sccache && 'true' || '' }}
          CARGO_INCREMENTAL: ${{ inputs.use_sccache && '0' || '' }}
        run: ${{ inputs.build_command }}

      - name: Run clippy
        if: inputs.enable_linting
        env:
          RUSTC_WRAPPER: ${{ inputs.use_sccache && 'sccache' || '' }}
          SCCACHE_GHA_ENABLED: ${{ inputs.use_sccache && 'true' || '' }}
          CARGO_INCREMENTAL: ${{ inputs.use_sccache && '0' || '' }}
          RUSTFLAGS: "-D warnings"
        run: ${{ inputs.lint_command }}

      - name: Run tests
        if: inputs.enable_tests && !inputs.enable_coverage
        env:
          RUSTC_WRAPPER: ${{ inputs.use_sccache && 'sccache' || '' }}
          SCCACHE_GHA_ENABLED: ${{ inputs.use_sccache && 'true' || '' }}
          CARGO_INCREMENTAL: ${{ inputs.use_sccache && '0' || '' }}
        run: ${{ inputs.test_command }} ${{ inputs.test_args }}

      - name: Run tests with coverage
        if: inputs.enable_tests && inputs.enable_coverage
        env:
          RUSTC_WRAPPER: ${{ inputs.use_sccache && 'sccache' || '' }}
          SCCACHE_GHA_ENABLED: ${{ inputs.use_sccache && 'true' || '' }}
          CARGO_INCREMENTAL: ${{ inputs.use_sccache && '0' || '' }}
        run: ${{ inputs.coverage_command }} ${{ inputs.test_args }}

      - name: Build integration test binaries
        if: inputs.enable_integration_tests && inputs.integration_build_command != ''
        env:
          RUSTC_WRAPPER: ${{ inputs.use_sccache && 'sccache' || '' }}
          SCCACHE_GHA_ENABLED: ${{ inputs.use_sccache && 'true' || '' }}
          CARGO_INCREMENTAL: ${{ inputs.use_sccache && '0' || '' }}
        run: ${{ inputs.integration_build_command }}

      - name: Run integration tests
        if: inputs.enable_integration_tests
        run: ${{ inputs.integration_test_command }}

      - name: Security audit with cargo-audit
        if: inputs.enable_security_audit
        env:
          RUSTC_WRAPPER: ${{ inputs.use_sccache && 'sccache' || '' }}
          SCCACHE_GHA_ENABLED: ${{ inputs.use_sccache && 'true' || '' }}
          CARGO_INCREMENTAL: ${{ inputs.use_sccache && '0' || '' }}
        run: ${{ inputs.audit_command }}

      - name: Security audit with cargo-deny
        if: inputs.enable_security_audit
        env:
          RUSTC_WRAPPER: ${{ inputs.use_sccache && 'sccache' || '' }}
          SCCACHE_GHA_ENABLED: ${{ inputs.use_sccache && 'true' || '' }}
          CARGO_INCREMENTAL: ${{ inputs.use_sccache && '0' || '' }}
        run: cargo deny check

      - name: Quality Gate - Test coverage shall be above threshold
        if: inputs.enable_coverage
        id: coverage-check
        shell: bash
        env:
          TESTCOVERAGE_THRESHOLD: ${{ inputs.coverage_threshold }}
        run: |
          echo "ğŸ” Quality Gate: Test Coverage Check"
          echo "Threshold: $TESTCOVERAGE_THRESHOLD%"
          echo "----------------------------------------"

          # Check if coverage file exists
          if [ ! -f "tarpaulin-report.json" ]; then
            echo "âŒ Coverage file not found: tarpaulin-report.json"
            echo "coverage_status=error" >> $GITHUB_OUTPUT
            echo "coverage_message=Coverage file not found: tarpaulin-report.json" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Extract coverage percentage from JSON using jq
          coverage_percent=$(jq -r '.coverage' tarpaulin-report.json 2>/dev/null)
          if [ -z "$coverage_percent" ] || [ "$coverage_percent" = "null" ]; then
            echo "âŒ Could not extract coverage from tarpaulin-report.json"
            echo "coverage_status=error" >> $GITHUB_OUTPUT
            echo "coverage_message=Could not extract coverage from tarpaulin-report.json" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Format to 2 decimal places
          coverage_percent=$(awk -v cov="$coverage_percent" 'BEGIN {printf "%.2f", cov}')
          echo "Current coverage: ${coverage_percent}%"
          echo "coverage_percentage=$coverage_percent" >> $GITHUB_OUTPUT

          # Validate coverage is a number using bash regex
          if ! [[ "$coverage_percent" =~ ^[0-9]+\.?[0-9]*$ ]]; then
            echo "âŒ Invalid coverage value: $coverage_percent"
            echo "coverage_status=error" >> $GITHUB_OUTPUT
            echo "coverage_message=Invalid coverage value: $coverage_percent" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Compare using awk for reliable float comparison
          result=$(awk -v cov="$coverage_percent" -v thresh="$TESTCOVERAGE_THRESHOLD" 'BEGIN {print (cov >= thresh)}')

          if [ "$result" = "1" ]; then
            echo "âœ… Coverage check PASSED (${coverage_percent}% >= ${TESTCOVERAGE_THRESHOLD}%)"
            echo "coverage_status=passed" >> $GITHUB_OUTPUT
            echo "coverage_message=Coverage check PASSED (${coverage_percent}% >= ${TESTCOVERAGE_THRESHOLD}%)" >> $GITHUB_OUTPUT
          else
            echo "âŒ Coverage check FAILED (${coverage_percent}% < ${TESTCOVERAGE_THRESHOLD}%)"
            echo ""
            echo "ğŸ’¡ To fix this:"
            echo "   â€¢ Add more unit tests to increase coverage"
            echo "   â€¢ Focus on untested critical paths"
            echo "   â€¢ Or adjust threshold if current coverage is acceptable"
            echo "coverage_status=failed" >> $GITHUB_OUTPUT
            echo "coverage_message=Coverage check FAILED (${coverage_percent}% < ${TESTCOVERAGE_THRESHOLD}%)" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Upload coverage report as artifact
        if: inputs.enable_coverage
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report-rust-${{ github.run_number }}${{ inputs.coverage_artifact_suffix != '' && format('-{0}', inputs.coverage_artifact_suffix) || '' }}
          path: ${{ inputs.package_path }}/tarpaulin-report.json
          retention-days: 15

      - name: Fail workflow if coverage check failed
        if: inputs.enable_coverage && steps.coverage-check.outputs.coverage_status == 'failed'
        run: |
          echo "âŒ Workflow failed due to insufficient test coverage"
          echo "Coverage: ${{ steps.coverage-check.outputs.coverage_percentage }}%"
          echo "Required: ${{ inputs.coverage_threshold }}%"
          exit 1


  post-coverage-comment:
    needs: checks-rust
    if: inputs.enable_coverage && inputs.post_pr_comment && (github.event_name == 'pull_request' || github.event_name == 'pull_request_target') && always() && needs.checks-rust.outputs.coverage_status != ''
    uses: ./.github/workflows/_post-pr-comment-reusable.yml
    secrets: inherit
    with:
      issue_number: ${{ github.event.number }}
      comment_identifier: "rust-coverage-report"
      comment_body: |
        ## ${{ needs.checks-rust.outputs.coverage_status == 'passed' && 'âœ…' || needs.checks-rust.outputs.coverage_status == 'failed' && 'âŒ' || 'âš ï¸' }} Rust Test Coverage Report
        
        | Metric | Value |
        |--------|-------|
        | **Current Coverage** | ${{ needs.checks-rust.outputs.coverage_percentage }}% |
        | **Required Threshold** | ${{ inputs.coverage_threshold }}% |
        | **Status** | **${{ needs.checks-rust.outputs.coverage_status == 'passed' && 'PASSED' || needs.checks-rust.outputs.coverage_status == 'failed' && 'FAILED' || 'ERROR' }}** |
        
        ${{ needs.checks-rust.outputs.coverage_status == 'failed' && '
        ### ğŸ’¡ How to improve coverage:
        - Add more unit tests to increase coverage
        - Focus on untested critical paths with `#[cfg(test)]` modules
        - Use `cargo tarpaulin --ignored` to include ignored tests
        - Consider adjusting threshold if current coverage is acceptable
        ' || '' }}
        
        --- 