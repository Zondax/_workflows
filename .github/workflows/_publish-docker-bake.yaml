name: Reusable Publish Docker (Bake)

on:
  workflow_call:
    inputs:
      # REGISTRY
      registry:
        description: "Target registry: 'dockerhub', 'gcp-ar', or 'both'"
        type: string
        default: "dockerhub"

      # BAKE CONFIGURATION
      bake_file:
        description: "Path to docker-bake.hcl"
        type: string
        default: "docker-bake.hcl"
      bake_targets:
        description: "Comma-separated targets (empty = default group)"
        type: string
        default: ""
      workdir:
        description: "Working directory"
        type: string
        default: "."

      # MULTI-ARCHITECTURE
      platforms:
        description: "Target platforms"
        type: string
        default: "linux/amd64"
      enable_multiarch:
        description: "Enable QEMU for cross-platform builds"
        type: boolean
        default: false

      # REMOTE BUILDER
      enable_remote_builder:
        description: "Use remote BuildKit builder for faster builds"
        type: boolean
        default: true
      remote_builder_url:
        description: "Remote BuildKit URL"
        type: string
        default: "tcp://buildkit.zondax.dev:8372"
      remote_builder_name:
        description: "Name for the remote builder instance"
        type: string
        default: "zondax-builder"

      # SECURITY
      enable_signing:
        description: "Sign images with Cosign (keyless OIDC)"
        type: boolean
        default: true
      enable_provenance:
        description: "Generate SLSA provenance"
        type: boolean
        default: true
      enable_sbom:
        description: "Generate SBOM"
        type: boolean
        default: false

      # STANDARD
      runner:
        description: "Runner to use for the workflow"
        type: string
        default: "zondax-runners"
      timeout_minutes:
        description: "Timeout in minutes for the job"
        type: number
        default: 30
      environment:
        description: "GitHub environment for accessing secrets/vars"
        type: string
        default: ""
      checkout_ref:
        description: "The ref to checkout (branch, tag, SHA)"
        type: string
        default: ""
      github_app_auth:
        description: "Use GitHub App Token for private repos"
        type: boolean
        default: false
      github_app_repos:
        description: "Additional repositories to access (one per line)"
        type: string
        default: ""

    secrets:
      DOCKERHUB_USER:
        description: "Docker Hub username"
        required: false
      DOCKERHUB_TOKEN:
        description: "Docker Hub access token"
        required: false
      app_id:
        description: "GitHub App ID"
        required: false
      app_pem:
        description: "GitHub App PEM"
        required: false

    outputs:
      image_tags:
        description: "All generated tags (newline-separated)"
        value: ${{ jobs.publish.outputs.image_tags }}
      image_digest:
        description: "Primary image digest"
        value: ${{ jobs.publish.outputs.image_digest }}
      bake_metadata:
        description: "Full bake output JSON"
        value: ${{ jobs.publish.outputs.bake_metadata }}

jobs:
  publish:
    runs-on: ${{ inputs.runner }}
    timeout-minutes: ${{ inputs.timeout_minutes }}
    environment: ${{ inputs.environment }}
    permissions:
      contents: read
      packages: write
      pull-requests: write # For PR comments
      id-token: write # For OIDC (Cosign, GCP WIF)

    outputs:
      image_tags: ${{ steps.tags.outputs.tags_file }}
      image_digest: ${{ steps.bake.outputs.digest }}
      bake_metadata: ${{ steps.bake.outputs.metadata }}

    steps:
      - name: Install deps
        run: |
          sudo apt-get update -y
          sudo apt-get install -yy git jq

      - name: Checkout with GitHub App
        uses: zondax/actions/checkout-with-app@v1
        with:
          github_app_auth: ${{ inputs.github_app_auth }}
          github_app_repos: ${{ inputs.github_app_repos }}
          fetch_depth: 0
          ref: ${{ inputs.checkout_ref || github.event.pull_request.head.ref || github.ref }}
          app_id: ${{ secrets.app_id }}
          app_pem: ${{ secrets.app_pem }}
          use_sudo: true

      - name: Set up QEMU
        if: inputs.enable_multiarch
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx (local)
        if: ${{ !inputs.enable_remote_builder }}
        uses: docker/setup-buildx-action@v3

      - name: Set up Docker Buildx (remote)
        if: ${{ inputs.enable_remote_builder }}
        uses: docker/setup-buildx-action@v3
        with:
          driver: remote
          endpoint: ${{ inputs.remote_builder_url }}

      - name: Login to Docker Hub
        if: contains(inputs.registry, 'dockerhub') || inputs.registry == 'both'
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USER }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Authenticate with GCP
        if: contains(inputs.registry, 'gcp') || inputs.registry == 'both'
        uses: zondax/actions/gcp-wif-auth@v1
        with:
          workload_identity_provider: ${{ vars.PULUMI_DEPLOY_WIF_PROVIDER }}
          setup_gcloud: true

      - name: Configure Docker for GCP AR
        if: contains(inputs.registry, 'gcp') || inputs.registry == 'both'
        run: gcloud auth configure-docker ${{ vars.PULUMI_GAR_LOCATION }}-docker.pkg.dev

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"

      - name: Generate Docker Tags
        id: tags
        working-directory: ${{ inputs.workdir }}
        run: |
          # Generate tags using zondax CLI
          # Filter out info lines (â„¹) that go to stdout, keep only HCL content
          npx -y @zondax/cli@latest ci tags \
            -f "${{ inputs.bake_file }}" \
            2>/dev/null | grep -v '^â„¹' > tags-override.hcl

          echo "Generated tags:"
          cat tags-override.hcl

          echo "tags_file=tags-override.hcl" >> $GITHUB_OUTPUT

      - name: Build and Push
        id: bake
        uses: docker/bake-action@v5
        with:
          workdir: ${{ inputs.workdir }}
          files: |
            ${{ inputs.workdir }}/${{ inputs.bake_file }}
            ${{ inputs.workdir }}/${{ steps.tags.outputs.tags_file }}
          targets: ${{ inputs.bake_targets }}
          push: true
          provenance: ${{ inputs.enable_provenance && 'mode=min' || 'false' }}
          sbom: ${{ inputs.enable_sbom }}
          set: |
            *.platform=${{ inputs.platforms }}
            *.output=type=registry,compression=zstd,compression-level=3

      - name: Install Cosign
        if: inputs.enable_signing
        uses: sigstore/cosign-installer@v3

      - name: Sign images
        if: inputs.enable_signing
        env:
          COSIGN_EXPERIMENTAL: "1"
        run: |
          METADATA='${{ steps.bake.outputs.metadata }}'
          for digest in $(echo "$METADATA" | jq -r '.[].digest // empty'); do
            echo "Signing: $digest"
            cosign sign --yes "$digest"
          done

      - name: Build Summary
        id: summary
        working-directory: ${{ inputs.workdir }}
        run: |
          METADATA='${{ steps.bake.outputs.metadata }}'

          # Build image list
          IMAGE_LIST=""

          for target in $(echo "$METADATA" | jq -r 'keys[]'); do
            # Get the first tag (primary tag like zondax/ubuntu-ci:22.04)
            IMAGE_REF=$(echo "$METADATA" | jq -r ".[\"$target\"].\"image.name\"" | tr ',' '\n' | head -1)
            DIGEST=$(echo "$METADATA" | jq -r ".[\"$target\"].\"containerimage.digest\"")

            if [ -n "$DIGEST" ] && [ "$DIGEST" != "null" ] && [ -n "$IMAGE_REF" ]; then
              FULL_REF="${IMAGE_REF}@${DIGEST}"
              SHORT_NAME="${IMAGE_REF%%:*}"

              # Query registry for manifest (we're already authenticated from the push)
              MANIFEST=$(docker buildx imagetools inspect "$FULL_REF" --raw 2>/dev/null || echo "{}")

              # Check if multi-platform manifest list or index
              if echo "$MANIFEST" | jq -e '.manifests' > /dev/null 2>&1; then
                FIRST_DIGEST=$(echo "$MANIFEST" | jq -r '.manifests[0].digest')
                PLATFORM=$(echo "$MANIFEST" | jq -r '.manifests[0].platform | "\(.os)/\(.architecture)"')
                LAYER_MANIFEST=$(docker buildx imagetools inspect "${SHORT_NAME}@${FIRST_DIGEST}" --raw 2>/dev/null || echo "{}")
              else
                LAYER_MANIFEST="$MANIFEST"
                PLATFORM="${{ inputs.platforms }}"
              fi

              # Get all tags for this target
              ALL_TAGS=$(echo "$METADATA" | jq -r ".[\"$target\"].\"image.name\"" | tr ',' '\n' | sed 's/^/- /')

              # Calculate total compressed size and layer details in one jq call
              read -r IMAGE_SIZE_MB LAYER_COUNT <<< $(echo "$LAYER_MANIFEST" | jq -r '
                [(.layers // [])[].size] |
                [(add // 0) / 1048576 | . * 100 | floor / 100, length] |
                @tsv' 2>/dev/null || echo "0 0")

              # Build layer breakdown (in order) with hash
              LAYER_DETAILS=$(echo "$LAYER_MANIFEST" | jq -r '
                (.layers // []) | to_entries | .[] |
                "L\(.key)  \(.value.digest | split(":")[1][0:12])  \(.value.size / 1048576 | . * 100 | floor / 100) MB"' 2>/dev/null || echo "")

              IMAGE_LIST="${IMAGE_LIST}
          **\`${IMAGE_REF}\`** (${PLATFORM})
          \`\`\`
          ${LAYER_DETAILS}
          Total: ${IMAGE_SIZE_MB} MB
          \`\`\`
          Tags:
          ${ALL_TAGS}
          "
            fi
          done

          # Generate summary content
          SUMMARY="## ðŸ³ Docker Build Summary

          ### Published Images
          ${IMAGE_LIST}
          ### Build Configuration
          - **Builder:** ${{ inputs.enable_remote_builder && format('Remote ({0})', inputs.remote_builder_url) || 'Local' }}
          - **Platforms:** \`${{ inputs.platforms }}\`
          - **Compression:** zstd
          - **Signed:** ${{ inputs.enable_signing && 'Yes' || 'No' }} | **SBOM:** ${{ inputs.enable_sbom && 'Yes' || 'No' }} | **Provenance:** ${{ inputs.enable_provenance && 'Yes' || 'No' }}"

          # Write to job summary
          echo "$SUMMARY" >> $GITHUB_STEP_SUMMARY

          # Save for PR comment
          EOF=$(dd if=/dev/urandom bs=15 count=1 status=none | base64)
          echo "comment_body<<$EOF" >> $GITHUB_OUTPUT
          echo "$SUMMARY" >> $GITHUB_OUTPUT
          echo "$EOF" >> $GITHUB_OUTPUT

      - name: Comment on PR
        if: github.event_name == 'pull_request'
        uses: peter-evans/create-or-update-comment@v4
        with:
          issue-number: ${{ github.event.pull_request.number }}
          body: |
            ${{ steps.summary.outputs.comment_body }}

            ---
            <sub>Build triggered by commit ${{ github.sha }}</sub>
          reactions: rocket
