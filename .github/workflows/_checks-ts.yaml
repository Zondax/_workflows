name: Reusable TypeScript Checks

on:
  workflow_call:
    inputs:
      enable_linting:
        description: "Enable linting checks"
        required: false
        type: boolean
        default: true
      enable_typecheck:
        description: "Enable TS typecheck"
        required: false
        type: boolean
        default: true
      enable_tests:
        description: "Enable tests execution"
        required: false
        type: boolean
        default: true
      enable_coverage:
        description: "Enable test coverage reporting"
        required: false
        type: boolean
        default: true
      upload_coverage:
        description: "Upload coverage reports to Codecov"
        required: false
        type: boolean
        default: false
      coverage_command:
        description: "Coverage command to run from package.json"
        required: false
        type: string
        default: "test:coverage"
      coverage_threshold_lines:
        description: "Minimum line coverage percentage required (0 to disable)"
        required: false
        type: number
        default: 0
      coverage_threshold_statements:
        description: "Minimum statement coverage percentage required (0 to disable)"
        required: false
        type: number
        default: 0
      coverage_threshold_functions:
        description: "Minimum function coverage percentage required (0 to disable)"
        required: false
        type: number
        default: 0
      coverage_threshold_branches:
        description: "Minimum branch coverage percentage required (0 to disable)"
        required: false
        type: number
        default: 0
      base_image:
        description: "Docker image to use (zondax/ubuntu-ci includes node, bun, pnpm, rust)"
        type: string
        default: "zondax/ubuntu-ci:24.04"
      test_command:
        description: "Test command to run from package.json"
        type: string
        default: "test"
      lint_command:
        description: "Lint command to run from package.json"
        type: string
        default: "lint"
      typecheck_command:
        description: "Typecheck command to run from package.json"
        type: string
        default: "typecheck"
      format_command:
        description: "Format command to run from package.json"
        type: string
        default: "format:check"
      checkout_submodules:
        description: "Checkout submodules"
        type: boolean
        default: true
      github_app_auth:
        description: "Use GitHub App Token"
        type: boolean
        default: false
      github_app_repos:
        description: "Additional repositories to access (one per line)"
        type: string
        default: ""
      codecov_flags:
        description: "Flags to pass to Codecov"
        type: string
        default: ""
      autoinit_env:
        description: "Automatically run env:init:ci script after installing dependencies"
        type: boolean
        default: false
      environment:
        description: "Environment name to use for accessing environment variables"
        type: string
        default: ""
      timeout_minutes:
        description: "Timeout in minutes for the job"
        type: number
        default: 10
      env_init_command:
        description: "Command to initialize environment (without package manager prefix)"
        type: string
        default: "env:init:ci"
      runner_preset:
        description: "Runner preset (linux-amd64, macos-arm64). Ignored when runs_on is set."
        type: string
        default: "linux-amd64"
      runs_on:
        description: "Runner label (e.g. 'ubuntu-latest', 'zondax-runners'). Overridden by runner_preset for macos-arm64."
        type: string
        default: "zondax-runners"
      cache_bucket:
        description: "S3-compatible bucket name for caching (e.g., Cloudflare R2)"
        type: string
        default: ""
      cache_endpoint:
        description: "S3-compatible endpoint URL for caching"
        type: string
        default: ""
      cache_region:
        description: "S3 region for cache"
        type: string
        default: "auto"
      enable_integration_tests:
        description: "Enable integration tests"
        type: boolean
        default: false
      integration_test_command:
        description: "Integration test command to run from package.json"
        type: string
        default: "test:integration"
      cache_pnpm:
        description: "Cache pnpm store to S3 (disable for dedicated/persistent runners)"
        type: boolean
        default: true
    secrets:
      app_id:
        description: "GitHub App ID"
        required: false
      app_pem:
        description: "GitHub App PEM"
        required: false
      codecov_token:
        description: "Codecov token for private repositories"
        required: false
      cache_access_key_id:
        description: "AWS/S3 access key ID for cache backend"
        required: false
      cache_secret_access_key:
        description: "AWS/S3 secret access key for cache backend"
        required: false

jobs:
  checks-ts:
    runs-on: ${{ fromJSON(inputs.runner_preset == 'macos-arm64' && '["self-hosted", "macOS", "ARM64"]' || format('["{0}"]', inputs.runs_on)) }}
    container: ${{ inputs.runner_preset != 'macos-arm64' && inputs.runs_on == 'zondax-runners' && inputs.base_image || '' }}
    timeout-minutes: ${{ inputs.timeout_minutes }}
    environment: ${{ inputs.environment }}
    permissions:
      contents: read
      id-token: write  # Required for Workload Identity Federation
      pull-requests: write  # Required for coverage report comments

    steps:
      - name: Setup Ubuntu packages
        # Skip when using zondax/ubuntu-ci (packages pre-installed, but sudo available if needed)
        if: inputs.runs_on == 'zondax-runners' && !startsWith(inputs.base_image, 'zondax/ubuntu-ci')
        uses: zondax/actions/setup-ubuntu-packages@v1
        with:
          packages: |
            - git
            - unzip
            - jq

      - name: Checkout with GitHub App
        uses: zondax/actions/checkout-with-app@v1
        with:
          github_app_auth: ${{ inputs.github_app_auth }}
          github_app_repos: ${{ inputs.github_app_repos }}
          checkout_submodules: ${{ inputs.checkout_submodules }}
          ref: ${{ github.event.pull_request.head.sha }}
          app_id: ${{ secrets.app_id }}
          app_pem: ${{ secrets.app_pem }}

      - name: Check for cache control in PR title
        id: cache-control
        shell: bash
        run: |
          PR_TITLE="${{ github.event.pull_request.title }}"
          if echo "$PR_TITLE" | grep -qiE '\[no[_-]?cache\]|\[cache[_-]?off\]'; then
            echo "Cache disabled via PR title"
            echo "enabled=false" >> $GITHUB_OUTPUT
          else
            echo "enabled=true" >> $GITHUB_OUTPUT
          fi

      - name: Authenticate with GCP
        if: ${{ inputs.autoinit_env && inputs.environment != '' }}
        uses: zondax/actions/gcp-wif-auth@v1
        with:
          workload_identity_provider: ${{ vars.PULUMI_FRONTEND_WIF_PROVIDER }}
          project_id: ${{ vars.PULUMI_GCP_PROJECT_ID }}

      - name: Setup mise
        uses: jdx/mise-action@v3
        with:
          install: true
          cache: false
          cache_save: false

      - name: Detect package manager
        id: pm
        run: |
          if mise tasks --no-header 2>/dev/null | grep -q "^ci_detect_pm"; then
            echo "$(mise run ci_detect_pm)" >> $GITHUB_OUTPUT
          else
            # Default detection
            if [ -f "bun.lockb" ] || [ -f "bun.lock" ]; then
              echo "pm=bun" >> $GITHUB_OUTPUT
              echo "pm_name=bun" >> $GITHUB_OUTPUT
            elif [ -f "pnpm-lock.yaml" ]; then
              echo "pm=pnpm run" >> $GITHUB_OUTPUT
              echo "pm_name=pnpm" >> $GITHUB_OUTPUT
            elif [ -f "yarn.lock" ]; then
              echo "pm=yarn run" >> $GITHUB_OUTPUT
              echo "pm_name=yarn" >> $GITHUB_OUTPUT
            elif [ -f "package-lock.json" ]; then
              echo "pm=npm run" >> $GITHUB_OUTPUT
              echo "pm_name=npm" >> $GITHUB_OUTPUT
            else
              echo "Error: Could not detect package manager. No lock file found (bun.lockb, bun.lock, pnpm-lock.yaml, yarn.lock, or package-lock.json)."
              echo "Either add a lock file or define a 'ci_detect_pm' mise task to specify the package manager."
              exit 1
            fi
          fi

      - name: Get pnpm store directory
        if: inputs.cache_pnpm && inputs.cache_bucket != '' && steps.pm.outputs.pm_name == 'pnpm'
        id: pnpm-cache
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path)" >> $GITHUB_OUTPUT

      - name: Cache pnpm store
        if: inputs.cache_pnpm && inputs.cache_bucket != '' && steps.pm.outputs.pm_name == 'pnpm' && steps.pnpm-cache.outputs.STORE_PATH != '' && steps.cache-control.outputs.enabled != 'false'
        uses: runs-on/cache@v4
        env:
          RUNS_ON_S3_BUCKET_CACHE: ${{ inputs.cache_bucket }}
          RUNS_ON_S3_FORCE_PATH_STYLE: "true"
          AWS_ACCESS_KEY_ID: ${{ secrets.cache_access_key_id }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.cache_secret_access_key }}
          AWS_ENDPOINT_URL: ${{ inputs.cache_endpoint }}
          AWS_REGION: ${{ inputs.cache_region }}
        with:
          path: ${{ steps.pnpm-cache.outputs.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-${{ github.ref_name }}
          restore-keys: |
            ${{ runner.os }}-pnpm-main
            ${{ runner.os }}-pnpm-dev
            ${{ runner.os }}-pnpm-

      - name: Cache Bun dependencies
        if: inputs.cache_bucket != '' && steps.pm.outputs.pm_name == 'bun' && steps.cache-control.outputs.enabled != 'false'
        uses: runs-on/cache@v4
        env:
          RUNS_ON_S3_BUCKET_CACHE: ${{ inputs.cache_bucket }}
          RUNS_ON_S3_FORCE_PATH_STYLE: "true"
          AWS_ACCESS_KEY_ID: ${{ secrets.cache_access_key_id }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.cache_secret_access_key }}
          AWS_ENDPOINT_URL: ${{ inputs.cache_endpoint }}
          AWS_REGION: ${{ inputs.cache_region }}
        with:
          path: ~/.bun/install/cache
          key: ${{ runner.os }}-bun-${{ hashFiles('bun.lockb', 'bun.lock') }}
          restore-keys: |
            ${{ runner.os }}-bun-

      - name: Prune stale pnpm store entries
        if: steps.pm.outputs.pm_name == 'pnpm'
        shell: bash
        run: pnpm store prune 2>/dev/null || true

      - name: Run ci_postinstall
        run: |
          if mise tasks --no-header 2>/dev/null | grep -q "^ci_postinstall"; then
            mise run ci_postinstall
          fi

      - name: Initialize environment
        if: ${{ inputs.autoinit_env }}
        run: ${{ steps.pm.outputs.pm }} ${{ inputs.env_init_command }}

      - name: Check format
        run: ${{ steps.pm.outputs.pm }} ${{ inputs.format_command }}

      - name: Run lint
        if: ${{ inputs.enable_linting }}
        run: ${{ steps.pm.outputs.pm }} ${{ inputs.lint_command }}

      - name: Run typecheck
        if: ${{ inputs.enable_typecheck }}
        run: ${{ steps.pm.outputs.pm }} ${{ inputs.typecheck_command }}

      - name: Run tests
        if: ${{ inputs.enable_tests && !inputs.enable_coverage }}
        run: ${{ steps.pm.outputs.pm }} ${{ inputs.test_command }}

      - name: Run tests with coverage
        if: ${{ inputs.enable_tests && inputs.enable_coverage }}
        run: ${{ steps.pm.outputs.pm }} ${{ inputs.coverage_command }}

      - name: Run integration tests
        if: ${{ inputs.enable_integration_tests }}
        run: ${{ steps.pm.outputs.pm }} ${{ inputs.integration_test_command }}

      - name: Vitest Coverage Report
        if: ${{ inputs.enable_tests && inputs.enable_coverage }}
        uses: davelosert/vitest-coverage-report-action@v2
        with:
          vite-config-path: ./vitest.config.ts
          working-directory: .

      - name: Quality Gate - Test coverage shall be above threshold
        if: ${{ inputs.enable_tests && inputs.enable_coverage && (inputs.coverage_threshold_lines > 0 || inputs.coverage_threshold_statements > 0 || inputs.coverage_threshold_functions > 0 || inputs.coverage_threshold_branches > 0) }}
        shell: bash
        env:
          THRESHOLD_LINES: ${{ inputs.coverage_threshold_lines }}
          THRESHOLD_STATEMENTS: ${{ inputs.coverage_threshold_statements }}
          THRESHOLD_FUNCTIONS: ${{ inputs.coverage_threshold_functions }}
          THRESHOLD_BRANCHES: ${{ inputs.coverage_threshold_branches }}
        run: |
          echo "üîç Quality Gate: Test Coverage Check"
          echo "----------------------------------------"

          # Check if coverage summary file exists
          if [ ! -f "coverage/coverage-summary.json" ]; then
            echo "‚ùå Coverage file not found: coverage/coverage-summary.json"
            echo "Make sure your coverage command generates a json-summary reporter"
            exit 1
          fi

          # Helper to safely extract and validate coverage metrics
          get_coverage_value() {
            local metric="$1"
            local value

            # Use jq -e to fail if the path does not exist; // empty prevents literal "null"
            if ! value=$(jq -e ".total.${metric}.pct // empty" coverage/coverage-summary.json 2>/dev/null); then
              echo "‚ùå Failed to read '${metric}' coverage from coverage/coverage-summary.json" >&2
              exit 1
            fi

            if [ -z "$value" ]; then
              echo "‚ùå Coverage value for '${metric}' is missing or null in coverage/coverage-summary.json" >&2
              exit 1
            fi

            if ! [[ "$value" =~ ^[0-9]+(\.[0-9]+)?$ ]]; then
              echo "‚ùå Coverage value for '${metric}' is not a valid number: '$value'" >&2
              exit 1
            fi

            echo "$value"
          }

          # Extract all coverage metrics with validation
          lines=$(get_coverage_value "lines")
          statements=$(get_coverage_value "statements")
          functions=$(get_coverage_value "functions")
          branches=$(get_coverage_value "branches")

          echo "üìä Current Coverage:"
          echo "  Lines:      ${lines}%"
          echo "  Statements: ${statements}%"
          echo "  Functions:  ${functions}%"
          echo "  Branches:   ${branches}%"
          echo ""
          echo "üìã Thresholds:"
          echo "  Lines:      ${THRESHOLD_LINES}%"
          echo "  Statements: ${THRESHOLD_STATEMENTS}%"
          echo "  Functions:  ${THRESHOLD_FUNCTIONS}%"
          echo "  Branches:   ${THRESHOLD_BRANCHES}%"
          echo "----------------------------------------"

          failed=0

          # Helper for portable floating point comparison using awk
          check_threshold() {
            local name="$1"
            local value="$2"
            local threshold="$3"

            # Skip if threshold is 0 (disabled) - use awk for numeric comparison
            if awk "BEGIN {exit !($threshold > 0)}"; then
              if awk "BEGIN {exit !($value >= $threshold)}"; then
                echo "‚úÖ ${name}: PASSED (${value}% >= ${threshold}%)"
              else
                echo "‚ùå ${name}: FAILED (${value}% < ${threshold}%)"
                return 1
              fi
            fi
            return 0
          }

          # Check each metric
          check_threshold "Lines     " "$lines" "$THRESHOLD_LINES" || failed=1
          check_threshold "Statements" "$statements" "$THRESHOLD_STATEMENTS" || failed=1
          check_threshold "Functions " "$functions" "$THRESHOLD_FUNCTIONS" || failed=1
          check_threshold "Branches  " "$branches" "$THRESHOLD_BRANCHES" || failed=1

          if [ "$failed" -eq 1 ]; then
            echo ""
            echo "üí° How to improve coverage:"
            echo "  - Add more unit tests for uncovered code paths"
            echo "  - Focus on critical business logic first"
            echo "  - Run your test:coverage script locally to see detailed report"
            exit 1
          fi

          echo ""
          echo "‚úÖ All coverage thresholds passed!"

      - name: Upload coverage reports to Codecov
        if: ${{ inputs.enable_tests && inputs.enable_coverage && inputs.upload_coverage }}
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.codecov_token }}
          flags: ${{ inputs.codecov_flags }}
          fail_ci_if_error: false
