name: Cloud Run Deploy Advanced (Reusable)

on:
  workflow_call:
    inputs:
      knative_yaml:
        required: true
        type: string
        description: Path to the Knative YAML manifest for deployment
      gcp_project_id:
        required: true
        type: string
        description: GCP project ID
      region:
        required: true
        type: string
        description: GCP region(s) for Cloud Run. JSON list for multi-region deploy (e.g. '["us-central1","europe-west1"]').
      workload_identity_provider:
        required: true
        type: string
        description: Workload identity provider
      service_account:
        required: true
        type: string
        description: GCP service account
      container_images:
        required: false
        type: string
        description: JSON map of container name to image (for multi-container deploys)
      container_configs:
        required: false
        type: string
        description: >-
          JSON map of container name to base64-encoded config content.
          Example: {"api":"base64content","envoy":"base64content","other-sidecar":"base64content"}
          The workflow will find the APP_CONFIG_FILE_B64 env var in each container and inject the config.
          
          Special keys for RBAC configuration:
          - "rbac_model": Injects into RBAC_MODEL_FILE_B64 env var in containers specified by rbac_containers input
          - "rbac_policy": Injects into RBAC_POLICY_FILE_B64 env var in containers specified by rbac_containers input
          
          Example with RBAC: {"api":"base64content","envoy":"base64content","rbac_model":"base64content","rbac_policy":"base64content"}
      rbac_containers:
        required: false
        type: string
        description: >-
          JSON array of container names that need RBAC configuration injection.
          Example: ["api", "store", "custom-service"]
          Required when using rbac_model or rbac_policy in container_configs.
    outputs:
      url:
        description: "The deployed Cloud Run service URL."
        value: ${{ jobs.deploy.outputs.url }}
jobs:
  deploy:
    runs-on: zondax-runners
    strategy:
      matrix:
        region: ${{ fromJson(inputs.region) }}
    outputs:
      url: ${{ steps.get-url.outputs.url }}
    permissions:
      id-token: write # Enables automatic ID token injection for google-github-actions/auth
      contents: read # Required for actions/checkout and GitHub API access
      pull-requests: write # Required for commenting on PRs
    steps:
      - uses: actions/checkout@v4

      - name: Authenticate with GCP
        id: auth
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ inputs.workload_identity_provider }}
          service_account: ${{ inputs.service_account }}
          
      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        
      - name: Install go
        uses: actions/setup-go@v5
        with:
          go-version: 1.24
        
      - name: Install yq
        run: |
          go install github.com/mikefarah/yq/v4@latest
          
      - name: Prepare Knative YAML for deploy
        id: prepare-yaml
        run: |
          # 1. Copy the Knative YAML manifest
          cp ${{ inputs.knative_yaml }} service.deploy.yaml

          # Replace PR_NUMBER placeholder if present (only for knative.yaml file, not config)
          sed -i "s#<PR_NUMBER>#${{ github.event.number }}#g" service.deploy.yaml
          # Replace <REGION> placeholder if present
          sed -i "s#<REGION>#${{ matrix.region }}#g" service.deploy.yaml

          # Process container images if specified
          if [ -n "${{ inputs.container_images }}" ]; then
            echo "Processing container images..."
            echo '${{ inputs.container_images }}' > container_images.json
            
            # Validate JSON before processing
            jq empty container_images.json 2>/dev/null || { echo "ERROR: Invalid container_images JSON format"; exit 1; }
            
            # Process each container image
            jq -r 'to_entries[] | [.key, .value] | @tsv' container_images.json | while read -r container_name image_url; do
              echo "Updating image for container: $container_name → $image_url"
              
              # Try placeholder replacement first
              placeholder="<${container_name^^}_IMAGE>"
              if grep -q "$placeholder" service.deploy.yaml; then
                sed -i "s#$placeholder#$image_url#g" service.deploy.yaml
              # Then try direct container name update if it has a placeholder
              elif yq e '.spec.template.spec.containers[] | select(.name == "'"$container_name"'") | .image' service.deploy.yaml | grep -q '<.*>'; then
                yq e '.spec.template.spec.containers[] |= select(.name == "'"$container_name"'").image = "'"$image_url"'"' -i service.deploy.yaml
              else
                echo "  Skipping container with static image"
              fi
            done
          fi

          # Inject configs if specified
          if [ -n "${{ inputs.container_configs }}" ]; then
            echo "Processing container configs..."
            echo '${{ inputs.container_configs }}' > container_configs.json
            jq empty container_configs.json 2>/dev/null || { echo "ERROR: Invalid container_configs JSON format"; exit 1; }
            
            # Process each configuration entry
            jq -r 'to_entries[] | [.key, .value] | @tsv' container_configs.json | while read -r name config; do
              # Replace PR number if needed
              [ -n "${{ github.event.number }}" ] && config=$(echo "$config" | base64 -d | sed "s/<github_event_number>/${{ github.event.number }}/g" | base64 -w 0)
              
              case "$name" in
                rbac_model)
                  # Inject RBAC model into specified containers
                  if [ -z "${{ inputs.rbac_containers }}" ]; then
                    echo "ERROR: rbac_containers input is required when using rbac_model"
                    exit 1
                  fi
                  echo '${{ inputs.rbac_containers }}' | jq -r '.[]' | while read -r container_name; do
                    if yq e '.spec.template.spec.containers[] | select(.name == "'"$container_name"'") | .env[] | select(.name == "RBAC_MODEL_FILE_B64")' service.deploy.yaml &>/dev/null; then
                      yq e '.spec.template.spec.containers[] |= select(.name == "'"$container_name"'").env[] |= select(.name == "RBAC_MODEL_FILE_B64").value = "'"$config"'"' -i service.deploy.yaml
                      echo "✓ Updated RBAC model config for container: $container_name"
                    else
                      echo "⚠️  Container '$container_name' does not have RBAC_MODEL_FILE_B64 env var, skipping"
                    fi
                  done
                  ;;
                rbac_policy)
                  # Inject RBAC policy into specified containers
                  if [ -z "${{ inputs.rbac_containers }}" ]; then
                    echo "ERROR: rbac_containers input is required when using rbac_policy"
                    exit 1
                  fi
                  echo '${{ inputs.rbac_containers }}' | jq -r '.[]' | while read -r container_name; do
                    if yq e '.spec.template.spec.containers[] | select(.name == "'"$container_name"'") | .env[] | select(.name == "RBAC_POLICY_FILE_B64")' service.deploy.yaml &>/dev/null; then
                      yq e '.spec.template.spec.containers[] |= select(.name == "'"$container_name"'").env[] |= select(.name == "RBAC_POLICY_FILE_B64").value = "'"$config"'"' -i service.deploy.yaml
                      echo "✓ Updated RBAC policy config for container: $container_name"
                    else
                      echo "⚠️  Container '$container_name' does not have RBAC_POLICY_FILE_B64 env var, skipping"
                    fi
                  done
                  ;;
                *)
                  # Validate container exists
                  yq e '.spec.template.spec.containers[] | select(.name == "'"$name"'") | .env[] | select(.name == "APP_CONFIG_FILE_B64")' service.deploy.yaml &>/dev/null || { echo "❌ Container '$name' or APP_CONFIG_FILE_B64 not found"; exit 1; }
                  yq e '.spec.template.spec.containers[] |= select(.name == "'"$name"'").env[] |= select(.name == "APP_CONFIG_FILE_B64").value = "'"$config"'"' -i service.deploy.yaml
                  echo "✓ Updated config for $name"
                  ;;
              esac
            done
          fi

          # Print deployment summary
          echo "\n===== DEPLOYMENT SUMMARY ====="
          SERVICE_NAME=$(yq -r '.metadata.name' service.deploy.yaml)
          echo "Service: $SERVICE_NAME"
          echo "Container images:"
          yq '.spec.template.spec.containers[] | [.name, .image] | join(": ")' service.deploy.yaml
          echo "============================="

      - name: Extract service name from YAML
        id: set-service-name
        run: |
          SERVICE_NAME=$(yq -r '.metadata.name' service.deploy.yaml)
          echo "final_service_name=$SERVICE_NAME" >> $GITHUB_OUTPUT
          echo "Deploying service: $SERVICE_NAME"

      - name: Deploy to Cloud Run
        id: deploy
        run: |
          # Deploy the Knative YAML using gcloud
          gcloud run services replace service.deploy.yaml \
            --region=${{ matrix.region }} \
            --project=${{ inputs.gcp_project_id }}
            
          echo "Service deployed successfully!"

      - name: Get service URL
        id: get-url
        run: |
          URL=$(gcloud run services describe ${{ steps.set-service-name.outputs.final_service_name }} \
            --platform=managed \
            --region=${{ matrix.region }} \
            --project=${{ inputs.gcp_project_id }} \
            --format='value(status.url)')
          echo "url=$URL" >> $GITHUB_OUTPUT
          echo "Service URL: $URL"
